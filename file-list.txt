| .env.botazon-local
DBHOST=[PLACEHOLDER]
DBUSER=[PLACEHOLDER]
DBPASSWORD=[PLACEHOLDER]
DBDATABASE=[PLACEHOLDER]
SPORT=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_ID=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_SECRET=[PLACEHOLDER]
AWS_ACCESS_KEY_ID=[PLACEHOLDER]
AWS_SECRET_ACCESS_KEY=[PLACEHOLDER]
AWS_SELLING_PARTNER_ROLE=[PLACEHOLDER]
sellerId=[PLACEHOLDER]
AmzToken=[PLACEHOLDER]
market_id=[PLACEHOLDER]
teleToken=[PLACEHOLDER]
| .env.botazon-server
DBHOST=[PLACEHOLDER]
DBUSER=[PLACEHOLDER]
DBPASSWORD=[PLACEHOLDER]
DBDATABASE=[PLACEHOLDER]
SPORT=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_ID=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_SECRET=[PLACEHOLDER]
AWS_ACCESS_KEY_ID=[PLACEHOLDER]
AWS_SECRET_ACCESS_KEY=[PLACEHOLDER]
AWS_SELLING_PARTNER_ROLE=[PLACEHOLDER]
sellerId=[PLACEHOLDER]
AmzToken=[PLACEHOLDER]
market_id=[PLACEHOLDER]
teleToken=[PLACEHOLDER]
| .env.fireball
DBHOST=[PLACEHOLDER]
DBUSER=[PLACEHOLDER]
DBPASSWORD=[PLACEHOLDER]
DBDATABASE=[PLACEHOLDER]
SPORT=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_ID=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_SECRET=[PLACEHOLDER]
AWS_ACCESS_KEY_ID=[PLACEHOLDER]
AWS_SECRET_ACCESS_KEY=[PLACEHOLDER]
AWS_SELLING_PARTNER_ROLE=[PLACEHOLDER]
sellerId=[PLACEHOLDER]
AmzToken=[PLACEHOLDER]
market_id=[PLACEHOLDER]
teleToken=[PLACEHOLDER]
| .env.fourseasons
DBHOST=[PLACEHOLDER]
DBUSER=[PLACEHOLDER]
DBPASSWORD=[PLACEHOLDER]
DBDATABASE=[PLACEHOLDER]
SPORT=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_ID=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_SECRET=[PLACEHOLDER]
AWS_ACCESS_KEY_ID=[PLACEHOLDER]
AWS_SECRET_ACCESS_KEY=[PLACEHOLDER]
AWS_SELLING_PARTNER_ROLE=[PLACEHOLDER]
sellerId=[PLACEHOLDER]
AmzToken=[PLACEHOLDER]
market_id=[PLACEHOLDER]
teleToken=[PLACEHOLDER]
| .env.fourseasons2
DBHOST=[PLACEHOLDER]
DBUSER=[PLACEHOLDER]
DBPASSWORD=[PLACEHOLDER]
DBDATABASE=[PLACEHOLDER]
SPORT=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_ID=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_SECRET=[PLACEHOLDER]
AWS_ACCESS_KEY_ID=[PLACEHOLDER]
AWS_SECRET_ACCESS_KEY=[PLACEHOLDER]
AWS_SELLING_PARTNER_ROLE=[PLACEHOLDER]
sellerId=[PLACEHOLDER]
AmzToken=[PLACEHOLDER]
market_id=[PLACEHOLDER]
| .env.rakoon

---
| .env.winter
DBHOST=[PLACEHOLDER]
DBUSER=[PLACEHOLDER]
DBPASSWORD=[PLACEHOLDER]
DBDATABASE=[PLACEHOLDER]
SPORT=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_ID=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_SECRET=[PLACEHOLDER]
AWS_ACCESS_KEY_ID=[PLACEHOLDER]
AWS_SECRET_ACCESS_KEY=[PLACEHOLDER]
AWS_SELLING_PARTNER_ROLE=[PLACEHOLDER]
sellerId=[PLACEHOLDER]
AmzToken=[PLACEHOLDER]
market_id=[PLACEHOLDER]
teleToken=[PLACEHOLDER]
| .env.winter2
DBHOST=[PLACEHOLDER]
DBUSER=[PLACEHOLDER]
DBPASSWORD=[PLACEHOLDER]
DBDATABASE=[PLACEHOLDER]
SPORT=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_ID=[PLACEHOLDER]
SELLING_PARTNER_APP_CLIENT_SECRET=[PLACEHOLDER]
AWS_ACCESS_KEY_ID=[PLACEHOLDER]
AWS_SECRET_ACCESS_KEY=[PLACEHOLDER]
AWS_SELLING_PARTNER_ROLE=[PLACEHOLDER]
sellerId=[PLACEHOLDER]
AmzToken=[PLACEHOLDER]
market_id=[PLACEHOLDER]
| .gitattributes
# Auto detect text files and perform LF normalization
* text=auto

---
| .gitignore
*.env*
*.log
endpoints*
*.json
---
| app.js
const express = require('express');
const app = express();
const routes = require('./routes/routes.js');
const logRoutes = require('./routes/log');
require('dotenv').config({path: `.env.${process.env.NODE_ENV}`})
port = process.env.SPORT;
require ('./src/cronjobs');

app.use(express.json());


app.use('/',routes);
app.use('/logs',logRoutes);

app.listen(port,()=> {
    console.log(`Listening on port ${port}`);
});

---
---
public/
| README.md
[ README.md ]
# AnmaSoftV3
 AnmaSoft V3 with telegram Support. Several fixes and code cleaning. 
 Saves into a MySQL database. No front end (yet) since I'm migrating from an old script.

MAIN FEATURES:
- Calculates zero-profit costs for all items in FBA. 
- Track your supplier's payments.  - (UNDER DEV)
- Track the amount of stock you have based on the cost and FBA information. 
- Estimate how many days in stock you've got. 
- Download and show inventory. 
- Download, update and calculate orders. 
- Calculate Customer Refunds
- Download Shipment Information (UNDER DEV)
- Calculate Profits on a Supplier's Pricelist. 
- Advisor on which items to make S&L on FBA. 
- Get all that information on a telegram bot. (UNDER DEV BUT WORKING)

----------------------------------------------------------------
Interested on collaborating? Give me a shout. 

---

routes/
| | log.js
const express = require('express');
const router = express.Router();

/**
 * 
 * SORRY
 * LOGS WERE
 * DEPRECATED
 * 
 */



///* --------------------------------------------------------- */
///* ---------------------ROUTES------------------------------ */
///* --------------------------------------------------------- */
//
///* ---------------------BASICS------------------------------ */
//
//router.get('/', (req, res) => {
//    res.sendFile(path.resolve('public/verLogs.html'));;
//});
//
///* -----------------INVENTORY REPORTS--------------------- */
//
//router.get("/createInventoryReportLog/",(req, res)=> {
//    res.sendFile(path.resolve('logs/createInventoryReport.log'));
//});
//
//router.get("/getInventoryReportLog/",(req, res)=> {
//    res.sendFile(path.resolve('logs/getInventoryReport.log'));
//});
//
//router.get('/updateInventoryInfoLog/', (req, res) => {
//    res.sendFile(path.resolve('logs/updateInventoryInfo.log'))
//});
//
///* -------------------ORDER REPORTS----------------------- */
//
//router.get("/createOrdersReportLog",(req, res)=> {
//    res.sendFile(path.resolve('logs/createOrdersReport.log'));
//});
//
//router.get("/createOrdersReportYesLog",(req, res)=> {
//    res.sendFile(path.resolve('logs/createOrdersReportYes.log'));
//});
//
//router.get("/createOrdersReportLMLog",(req, res)=> {
//    res.sendFile(path.resolve('logs/createOrdersReportLM.log'));
//});
//
//router.get("/getOrdersReportLog",(req, res)=>{
//    res.sendFile(path.resolve('logs/getOrdersReport.log'));
//});
//
//router.get("/updateMissingOrdersLog",(req, res)=> {
//    res.sendFile(path.resolve('logs/updateMissingOrders.log'));
//});
//
//router.get('/estimateOrdersLog',(req, res)=>{
//    res.sendFile(path.resolve('logs/estimateOrders.log'));
//});
//
///* -------------------RETURN REPORTS----------------------- */
//
//router.get("/createReturnsReportLog",(req, res)=>{
//    res.sendFile(path.resolve('logs/createReturnsReport.log'));
//});
//
//router.get("/createReturnsReportYesLog",(req, res)=> {
//    res.sendFile(path.resolve('logs/createReturnsReportYes.log'));
//});
//
//router.get("/getReturnsReportLog",(req, res)=>{
//    res.sendFile(path.resolve('logs/getReturnsReport.log'));
//});
//
///* -------------------CALCULAR CEROS----------------------- */
//
//router.get('/calcularCostosLog', (req, res)=> {
//    res.sendFile(path.resolve('logs/calcularCostos.log'));
//});
//
///* ---------------------TOOLS------------------------------ */
//
//router.get('/smallAndLightLog', (req, res)=> {
//    res.sendFile(path.resolve('logs/smallAndLight.log'));
//});
//
///* ----------------- FOREVER -------------------------------*/
//router.get('/forever1', (req, res)=> {
//    res.sendFile(path.resolve('/root/.forever/qpT_.log'));
//});
//
//router.get('/forever2', (req, res)=> {
//    res.sendFile(path.resolve('/root/.forever/fyim.log'));
//});
//
//router.get('/forever3', (req, res)=> {
//    res.sendFile(path.resolve('/root/.forever/Reip.log'));
//});
//
//
//
module.exports = router;
---
| | routes.js
const express = require('express');
const router = express.Router();
var path = require('path');


/* --------------------------------------------------------- */
/* ---------------------REQUIREMENTS------------------------ */
/* --------------------------------------------------------- */

/* ------------------INVENTORY REPORTS---------------------- */

const inventoryUpdater = require('../src/inventory/updateInventory');
const {calcularStock} = require('../src/inventory/stock/calcularStock')
const {select} = require('../src/shipments/shipmentAdvisor');

/* --------------------ORDER REPORTS------------------------ */

const {orderHandler} = require('../src/orders/orderHandler');
const {profitCalc} = require('../src/orders/profitCalculator');

///* -------------------RETURN REPORTS----------------------- */

const {refundHandler} = require('../src/refunds/refundHandler');

///* -------------------CALCULAR CEROS----------------------- */

const {calcularCostos} = require('../src/finances/calcularCostos.js');

///* ---------------------TOOLS------------------------------ */

const {smallAndLightTool} = require('../src/tools/smallAndLight.js');
const {telebot} = require ('../src/telegramBot')
const {restockCalculator} = require('../src/inventory/stock/restock');
const {feedbackReport} = require ('../src/tools/feedback')

/* --------------------------------------------------------- */
/* ---------------------ROUTES------------------------------ */
/* --------------------------------------------------------- */

/* ---------------------BASICS------------------------------ */

router.get('/', (req, res) => {
    res.send(`Panel de control`);
});

router.get('/controlPanel', (req, res) => {
    
    res.sendFile(path.resolve('public/controlPanel.html'));
});

/* -----------------INVENTORY REPORTS--------------------- */

router.get("/inventory/",(req, res)=> {
    inventoryUpdater.inventory();
    res.send('Lanzado inventory');
});

router.get("/calcularStock/",(req, res)=> {
    calcularStock();
    restockCalculator();
    res.send('Lanzado Calcular Stock y Restock');
});

/* -------------------ORDER REPORTS----------------------- */

router.get("/orderHandler/",(req, res)=> {
    orderHandler();
    res.send('Lanzado Order Handler');
});

router.get("/profitCalculator/",(req, res)=> {
    profitCalc();
    res.send('Lanzado Profit Calculator');
});

/* -------------------RETURN REPORTS----------------------- */

router.get("/refundHandler/",(req, res)=> {
    refundHandler();
    res.send('Lanzado Refund Handler');
});

/* -------------------CALCULAR CEROS----------------------- */

router.get('/calcularCostos', (req, res)=> {
    calcularCostos();
    res.send(`Se estan calculando costos.`);
});

/* -------------------SHIPMENT TOOLS----------------------- */

router.get('/shipments', (req, res)=> {
    select();
    res.send(`Probando shipments.`);
});

/* ---------------------TOOLS------------------------------ */

router.get('/smallAndLightTool', (req, res)=> {
    smallAndLightTool();
    res.send(`Reporte de Small and Light en proceso. Ver LOG!.`);
});

router.get('/restock', (req, res)=> {
    restockCalculator();
    res.send(`Restock a la vista..`);
});

router.get('/feedback', (req, res)=> {
    feedbackReport();
    res.send(`Feedback stuff`);
});


module.exports = router;
---
src/
| | basicReq.js
//requests for mysql and SP-API, promises, telegram bot. This

const mysql = require('mysql2');
require('dotenv').config({path: `.env.${process.env.NODE_ENV}`})
const util = require('util');

const pool = mysql.createPool({
  connectionLimit : 50, //important
  host     : process.env.DBHOST,
  user     : process.env.DBUSER,
  password : process.env.DBPASSWORD,
  database : process.env.DBDATABASE,
  debug    :  false
},()=>console.log('Connected!'));

let query = util.promisify(pool.query).bind(pool);

module.exports = {query}
---
| | cronjobs.js
const CronJob = require("cron").CronJob;
const { calcularCostos } = require("./finances/calcularCostos");
const { updInventory } = require("./inventory/updateInventory");
const { calcularStock } = require("./inventory/stock/calcularStock");
const { orderHandler } = require("./orders/orderHandler");
const { profitCalc } = require("./orders/profitCalculator");
const { refundHandler } = require("./refunds/refundHandler");
const { feedbackHandler } = require("./telegramBot");
const { updateStorageFees } = require("./finances/calcularStorage");
const {query} = require("./basicReq");

//EVERY 30 MINUTES:
const cron30min = new CronJob(
  "*/30 * * * *",
  () => {
    feedbackHandler();
    calcularCostos();
    console.log("cron30min iniciado");
  },
  null,
  true,
  "Atlantic/St_Helena"
);

//EVERY 2 HOURS:

const cron2hs1 = new CronJob(
  "00 */2 * * *",
  () => {
    orderHandler();
    console.log("cron2hs1 iniciado");
  },
  null,
  true,
  "Atlantic/St_Helena"
);

const cron2hs2 = new CronJob(
  "10 */2 * * *",
  () => {
    profitCalc();
    console.log("cron2hs2 iniciado");
  },
  null,
  true,
  "Atlantic/St_Helena"
);

//EVERY 4 HOURS:

const cron4hs1 = new CronJob(
  "04 */4 * * *",
  () => {
    updInventory();
    console.log("cron4hs1 iniciado");
  },
  null,
  true,
  "Atlantic/St_Helena"
);

const cron4hs2 = new CronJob(
  "15 */4 * * *",
  () => {
    calcularStock();
    console.log("cron4hs2 iniciado");
  },
  null,
  true,
  "Atlantic/St_Helena"
);

const cron4hs3 = new CronJob(
  "08 */4 * * *",
  () => {
    refundHandler();
    console.log("cron4hs1 iniciado");
  },
  null,
  true,
  "Atlantic/St_Helena"
);

//EVERYDAY:

const cronEveryday = new CronJob(
  "30 0 * * *",
  async () => {
    await query("UPDATE datos_pos SET needs_update = 1 WHERE active = 1");
    updateStorageFees();
    console.log("cronEveryday iniciado");
  },
  null,
  true,
  "Atlantic/St_Helena"
);


---
| finances/
| | | calcularCostos.js
//getMyFeesEstimateForSKU

const {query} = require('../basicReq');

let sellingPartner  = require (`../sellerApiReq`);


class precioItem {
    constructor(sku,precio,fee,costo,cero,offset,last_update,supplierId,buyerId) {
        this.sku = sku;
        this.precio = precio;
        this.fee = fee;
        this.costo = costo;
        this.cero = cero;
        this.offset = offset;
        this.last_update = last_update;
        this.supplierId = supplierId;
        this.buyerId = buyerId;
    }
}

itemsList = [];

async function queryDB(){
    let res = await query(`SELECT * FROM datos_pos WHERE active = '1' AND needs_update = '1' GROUP BY sku ORDER BY sku`);
    let res2 = await query(`SELECT * FROM datos_costos`);
    let i = 0;
    let skuList = [];
    //console.log(res.length);
    while (i < res.length) {
        let lpm = new precioItem(res[i].sku,100,0,res[i].total_cost,100,100,null,res[i].provider_id,res[i].buyer_id);  
            for (let j=1;j<res.length;j++){
                if (typeof res[j]?.length != 'undefined'){
                if (res[i].sku == res2[j].sku){
                    lpm.cero = parseFloat(res2[j].cero).toFixed(3); 
                    lpm.precio = parseFloat(res2[j].cero).toFixed(3); 
                }
                else
                break;
            }
        }
        skuList.push(lpm);
        i++;
        }
        if (i> 0){
            console.log(`Son ${i} SKUs`);
        return skuList;
        }
    else
    {
        console.log('No hay skus pendientes');
        return 0;
    }
}


async function calcularFee(id){
    let res = await sellingPartner.callAPI({
        operation:'getMyFeesEstimateForSKU',
        endpoint:'productFees',
        body:{
            FeesEstimateRequest: {
                MarketplaceId: 'ATVPDKIKX0DER',
                IsAmazonFulfilled: true,
                PriceToEstimateFees:{
                ListingPrice:{
                    Amount: id.precio,
                    CurrencyCode: 'USD',
                },
                },
                Identifier: id.sku,
                }
            },
                
        path: {
                SellerSKU: id.sku
                }
                }
);
//console.log(res);
    if(typeof res.FeesEstimateResult?.FeesEstimate == 'undefined' || res.FeesEstimateResult?.Status == 'ClientError'){
        console.log(`Error por status ${res?.FeesEstimateResult?.Status} ${res.toString()}`);
        console.table(res?.FeesEstimateResult?.Error)
        return 0;
    }
    console.log(res.FeesEstimateResult?.FeesEstimate?.TotalFeesEstimate?.Amount)
    id.fee = res.FeesEstimateResult?.FeesEstimate?.TotalFeesEstimate?.Amount;
    return (id);
}


function calcularOffset(id){
    let fee = id.fee;
    let retorno = id;
    let offset = retorno.precio - fee - retorno.costo;

    if ((offset > 0.02) || (offset < 0.02))
{
    if (retorno.last_update == null)
    console.log(`Primera vuelta de ${retorno.sku}`);
        retorno.precio -= offset;
        retorno.offset = offset;
        retorno.fee = fee;
        retorno.last_update = new Date().toISOString().slice(0,19) + '+00:00';
        //console.log(retorno);
        return retorno;
}
else
//console.log(retorno);
console.log(`Todo sigue igual.`)
}

async function actualizarDB(id){
    //Check if exists
    res = await query (`SELECT * FROM datos_costos WHERE sku = '${id.sku}'`);
    if (res.length > 0)
    {
        await query (`UPDATE datos_costos SET cero = '${id.cero}',check_cero = '${id.offset}',last_updated = '${id.last_update}' WHERE sku = '${id.sku}'`);
        await query (`UPDATE datos_pos SET needs_update = 0 WHERE sku = '${id.sku}'`);
        console.log(`SKU ${id.sku} Actualizado.`);
    }
    else 
    {
        await query (`INSERT INTO datos_costos (sku,costo,cero,profit30,profit50,check_cero,last_updated,hard_top,hard_low_MAP,buyerId,supplierId) VALUES ('${id.sku}','${id.costo}','${id.cero}','0','0','${id.offset}','${id.last_update}','0','0','${id.buyerId}','${id.supplierId}')`);
        await query (`UPDATE datos_pos SET needs_update = 0 WHERE sku = '${id.sku}'`);
        console.log(`SKU: ${id.sku} Agregado.`)
    }
    
}


async function calcularCostos(){
    let item = await queryDB();
        //console.log(item);
        if (typeof item === 'undefined'){
            return 0;
        }
   for (let i = 0; i < item.length; i++) {
    console.log(`Actualizando ${item[i].sku}`);
        let vuelta1 = await calcularFee(item[i]);
        if (vuelta1 == 0){
            console.log(`ERROR CATASTROFICO ${item[i].sku}`)
            continue;
        }
        let vuelta2 = calcularOffset(vuelta1);
        while (vuelta2?.offset >0.02)
        {
            vuelta1 = await calcularFee(vuelta2);
            vuelta2 = calcularOffset(vuelta1);
        };
        test = vuelta2;
        if (!test) continue;
        test.cero = test?.precio;
        console.log(`El precio se ha actualizado. Ahora es ${test?.cero}`);
        await actualizarDB(test); 
        }        
    }

module.exports = {calcularCostos};

---
| | | calcularStorage.js
const {query} = require('../basicReq');

const feetToInches = 1/12;

async function getItems(){
    return await query(`SELECT * FROM datos_items WHERE weight > 0`);
}

async function getPos(sku) {
    return await query(`SELECT * FROM datos_pos WHERE sku = '${sku}'`);
}

async function updateStorageFees() {
    const fecha = new Date().getMonth();
    let items = await getItems();
    if (items.length > 0) {
        for (const item of items){
    let width = item.width * feetToInches;
    let length = item.length * feetToInches;
    let height = item.height * feetToInches;
    let weight = item.weight * feetToInches;
    let cubicFeet = width * height * length;
    let tipo ="";
    let storage = 0;
    if (length > 18 || width > 14 || height > 8 || weight > 20){
        if (fecha >= 10){
            tipo = 'OVERSIZE - Q4';
            storage = cubicFeet * 1.20;
        }
        else
        {
            tipo = 'OVERSIZE - Q1/2/3';
            storage = cubicFeet * 0.48;
        }
    }
    else
    {
        if (fecha>= 10){
            tipo = 'STANDARD - Q4';
            storage = cubicFeet * 2.4;
        }
        else
        {
            tipo = 'STANDARD - Q1/2/3';
            storage = cubicFeet * 0.75;
        }
    }
    let todo = await getPos(item.sku);
        todo.forEach(itemEnPo=>{
            //console.log(itemEnPo.cost ," ",itemEnPo.label ," ", itemEnPo.shipment ," ", storage ," ", itemEnPo.manualfee);
            let totalcost = itemEnPo.cost + itemEnPo.label + itemEnPo.shipment + storage + itemEnPo.manualfee;
            totalcost = parseFloat(totalcost.toFixed(3));
            saveItem({storage: storage,totalcost:totalcost,id:itemEnPo.id});
            console.log(`Saved: ${item.sku} antes: ${itemEnPo.monthlyfee?.toFixed(3)} y ahora: ${storage.toFixed(3)}.`);
        })    
}
}
console.log(`Actualizado Strorage Fee. Procediendo a actualizar los monthly en suma.`);
await updateMonthlyStorageFees();

}

async function saveItem(item){
    await query(`UPDATE datos_pos SET monthlyfee = '${item.storage.toFixed(3)}', total_cost = ${parseFloat(item.totalcost).toFixed(3)} WHERE id = '${item.id}'`);
}

async function getAllPOs(){
    return await query (`SELECT * FROM datos_pos WHERE date_po != '-'`);
}


async function updateMonthlyStorageFees(){
let hoy = new Date();
let pos = await getAllPOs();
for (let item of pos){
    let fecha = new Date (item.date_po);
    let meses = Math.ceil(Math.abs(fecha-hoy) / (1000 * 60 * 60 * 24 * 30));
    let monthlyNuevo = parseFloat(item.monthlyfee * meses).toFixed(3);
    let totalcost = item.cost + item.label + item.shipment + item.manualfee + monthlyNuevo;
    await saveNewMonthly(monthlyNuevo,totalcost,item.id);
    console.log(`Saved ${item.sku} de ${item.monthlyfee_total} a ${monthlyNuevo}`);
}
console.log(`monthlyfee total actualizado.`)
}
async function saveNewMonthly(mft,tc,id){
    mft = parseFloat(mft).toFixed(3);
    tc = parseFloat(tc).toFixed(3);
    await query (`UPDATE datos_pos SET monthlyfee_total = '${mft}', total_cost = '${tc}' WHERE id = ${id}`);
}

module.exports = {updateStorageFees};
---
| | ganancias/
| | | | calcularGanancias.js
const {query} = require('../basicReq');

let sellingPartner  = require (`../sellerApiReq`);


---
| | payments/
| | | | payments.js
/*

UNDER DEVELOPMENT


Bueno, me la re complique al pedo. Si es un pago parcial que se maneje. 
Si es un pago de una PO, se paga la PO, si es un expense, se maneja sin PO. 
Si es pago parcial, se paga parcial y se deja ahi boyando. UN SOLO PAGO. no subpagos. 
*/
/*
UN PAGO CONTIENE: 
    this.id; //PAYMENT ID.
    this.type = type; //Supplier - Expense - Settlement - Refund - Sale
    this.amount = amount; //Amount PAID.
    this.description = description; //Some reference.
    this.supplierId = supplierId; // Supplier Tied to
    this.invoiceId = invoiceId; //Invoice Id for search
    this.netTerms = netTerms; //Terms. (EN DIAS)
    this.paymentDate = paymentDate; //When we paid
    this.dueDate = dueDate; //When should have been paid by
    this.poNumber = poNumber; // PO


----------------------------------------------------------------*/

const {query} = require('../../basicReq');

class Payment { 
    constructor(type,amount,description,supplierId,invoiceId,netTerms,paymentDate,dueDate,poNumber,id){
    if (typeof id !== 'undefined')
        this.id = id; //PAYMENT ID.
        else
        this.id;
    this.type = type; //Supplier - Expense - Settlement - Refund - Sale
    this.amount = amount; //Amount PAID.
    this.description = description; //Some reference.
    this.supplierId = supplierId; // Supplier Tied to
    this.invoiceId = invoiceId; //Invoice Id for search
    console.log(`Acabo de guardar como invoice id: ${this.invoiceId} que vino como ${invoiceId}`);
    this.netTerms = netTerms; //Terms. (EN DIAS)
    this.paymentDate = paymentDate; //When we paid
    this.dueDate = dueDate; //When should have been paid by
    this.poNumber = poNumber; // PO
    }

    
static async loadPayment(id) {
    //if the idea is to update a payment, I can load it just for you.
    try {
        let pago = await query(`SELECT * FROM payments WHERE id = '${id}'`);
    if (typeof pago !== 'undefined') { 
        return new Payment (pago[0].type, pago[0].amount, pago[0].description,pago[0].supplierId,pago[0].invoiceId,pago[0].netTerms,pago[0].paymentDate,pago[0].dueDate,pago[0].poNumber,pago[0].id);
    }
    else {console.warn(`Payment ID: ${id} not found`); return 0;}}
    catch (e) {
        console.warn(`Catched! `,e);
        return -1;
    }
}
async savePayment(){
    //Once everything's said and done, save the payment, and save the payment into said PO. 
    try {
        if (typeof this.id == 'undefined') {
            query(`INSERT INTO payments (type,amount,description,supplierId,invoiceId,netTerms,paymentDate,dueDate,poNumber) VALUES ('${this.type}','${this.amount}','${this.description}','${this.supplierId}','${this.invoiceId}','${this.netTerms}','${this.paymentDate}','${this.dueDate}','${this.poNumber}')`); //INSERTS NEW ROW 
        }
        else{
            query(`REPLACE INTO payments (id,type,amount,description,supplierId,invoiceId,netTerms,paymentDate,dueDate,poNumber) VALUES ('${this.id}','${this.type}','${this.amount}','${this.description}','${this.supplierId}','${this.invoiceId}','${this.netTerms}','${this.paymentDate}','${this.dueDate}','${this.poNumber}')`); //TRIES TO UPDATE DB
        }
    }
    catch (e){
        console.warn(`Catched! `,e);
        return -1; // ERROR CODE -1
    }
    return true; //EVERYTHING WELL
}


async paymentPOVerification(poNumber){
    //te dice si hay un pago para esta PO.
    let res = await query(`SELECT * FROM payments WHERE poNumber = '${poNumber}'`)
    if ( typeof res != 'undefined')
    {   //hay un pago. Devolver id
        return res[0].id;
    }
    return 0;
}

pay(amount){
    this.amount += amount;
    this.paymentDate = new Date ().toISOString();
}

static async payByPO(poNumber,amount){
    //PO Number es obvio, el numero de PO. Amount, cuanto se paga / agrega si ya existe.
    //Hay que ver si existe... 
    let pago;
    let id = await this.paymentPOVerification(poNumber);
    if (id != 0 || typeof id != 'undefined'){ 
        //Si existe, cargo el pago.
        pago = await Payment.loadPayment(pago.id);
        //Cargado el pago, ahora le sumo el amount.
        if (pago != -1){
            pago.pay(amount);
        return await pago.savePayment() // TRUE O ERROR DE SAVE
        }
        return -1; //PAGO MAL CARGADO.
    }
    return 0; //ERROR DE PAYBYPO. No existe la PO. 
}

static async telePayment (obj){
    //Recibo un pago de Telegram. Subo al toque. 
    let newTelePay = new Payment (obj.type,obj.amount,obj.description,obj.supplierId, obj.invoiceId ,obj.netTerms,obj.paymentDate,obj.dueDate,obj.poNumber,obj.id);
    let res = newTelePay.savePayment();
    return res;
}

}


module.exports = Payment;


---
| inventory/
| | | newUpdateInvInfo.js
//Updates the images, dimensions and weight of an item once a day. 

const {query} = require('../basicReq');

let sellingPartner  = require (`../sellerApiReq`);

async function cleanResponse(someRes){
    let cmtoi = 1 / 2.54;
    let length,width,height,weight = 0;
   if (someRes?.attributes?.item_package_dimensions){
    if (someRes.attributes.item_package_dimensions[0]?.length?.unit == 'centimeters'){
        length = someRes.attributes.item_package_dimensions[0]?.length?.value * cmtoi;
        width = someRes.attributes.item_package_dimensions[0]?.width?.value * cmtoi;
        height = someRes.attributes.item_package_dimensions[0]?.height?.value * cmtoi;
    }
    else
    {console.log(`HAY UNO QUE NO TRAIA CMS`)}
    if (someRes?.attributes?.item_package_weight[0]?.unit == 'kilograms'){
        weight = someRes?.attributes?.item_package_weight[0]?.value * 2.205;
    }
    else if(someRes?.attributes?.item_package_weight[0]?.unit == 'pounds'){
        weight = someRes?.attributes?.item_package_weight[0]?.value;
    }
    else
    console.log(`HAY UNO QUE NO TRAIA KG NI LB!!!`)
    if (!length || !height || !width || !weight){
        console.log(`Error en alguno.`)
        return 0;
    }
    else
    {
        length = parseFloat(length.toFixed(3));
        height = parseFloat(height.toFixed(3));
        width = parseFloat(width.toFixed(3));
        weight = parseFloat(weight.toFixed(3))
        return {width:width,height:height,length:length,weight:weight}
    }
   };
}

async function getListingsItem(sku){
    try {
        let res = await sellingPartner.callAPI({
            operation:'getListingsItem',
            endpoint:'listingsItems',
            query:     
            {
             marketplaceIds : process.env.market_id,
             //includedData : includedData
            },
            path: {
                    sku: sku,
                    sellerId: process.env.sellerId,
                    }
                    }
    );
        //console.log(res.summaries[0]?.mainImage?.link)
        return res.summaries[0]?.mainImage?.link;
    }
    catch (e){
        e.code=='NOT_FOUND'?console.log('No estaba la imagen'):console.log(e);
        return 'https://static8.depositphotos.com/1009634/988/v/450/depositphotos_9883921-stock-illustration-no-user-profile-picture.jpg';
    }
}

async function saveItem(item){
    try{
    await query (`UPDATE datos_items SET height = '${item.height}', width ='${item.width}', length = '${item.length}', weight = '${item.weight}',imageurl = '${item.url}' WHERE 'sku' = '${item.sku}'`)
    }
    catch (e){
        console.log(e)
    }
}

async function getCatalogItem(asin) {
    try {
        let res = await sellingPartner.callAPI({
            operation:'getCatalogItem',
            endpoint: 'catalogItems',
            query: {
                marketplaceIds: ['ATVPDKIKX0DER'],
                includedData: ['attributes'],
            },
            path: {
                asin: asin
            },
            options:{
                version:'2020-12-01'
              }
        })
    //console.log(res.attributes.item_package_dimensions[0]);
    let clean = await cleanResponse(res);
    clean.asin = asin;
    return clean;
    }
    catch (e){
        e.code=='NOT_FOUND'?console.log('No existe mas el item'):console.log(e);
        return 0;
    }
}

async function getAllItems(){
    let e = await query(`SELECT * FROM datos_items WHERE 'ignorar' = 0`);
    return (e.length > 0)?e:0;
}

async function ignoreItem(asin){
    await query (`UPDATE datos_items SET ignorar = 1 WHERE asin = '${asin}'`);
}

async function updateItemInfo (){
    let items = await getAllItems();
    for (let item of items){ 
        let catItem = await getCatalogItem(item.asin);
        if (catItem != 0){
            catItem.url = await getListingsItem(item.sku);
            console.log(catItem.asin)
            saveItem(catItem);
        }
        else
        {
            console.log(`Error en ${item.asin}, posiblemente eliminado, lo ignoro de ahora en mas`);
            await ignoreItem(item.asin);
        }
    }
}


module.exports = {updateItemInfo}

---
| | stock/
| | | | calcularStock.js
//How much money a user (or admin) has in stock. (Doesn't yet include PAYMENTS, but it will.)


const {query} = require('../../basicReq');

async function pedirStock(){
    let stock = await query (`SELECT * FROM datos_items WHERE afnfulfillablequantity > 0`);
    let pureStock = [];
    for (let i = 0; i < stock.length; i++){
        let productoEnStock = {sku: stock[i].sku, cantidad: stock[i].afnfulfillablequantity, comprador: 0, user: '', cost: 0,total: 0,fnsku: stock[i].fnsku,userid:0};
        pureStock.push(productoEnStock);
    };
    //console.log(pureStock);
    return pureStock;
}

async function pedirPagos(){
    //Pedir Pagos Pendientes de envio. Por ahora, ponemos esto en 0
    return 0;
}

async function pedirPOs(){
    //Pedir POs General
    let POs = await query (`SELECT * FROM datos_pos WHERE active = 1`);
    let purePOs = [];
    for (let i = 0; i < POs.length; i++){
        let producto = {sku: POs[i].sku, cost: POs[i].cost, comprador: POs[i].buyer_id}
        purePOs.push(producto);
    }
    //console.log(purePOs);
    return purePOs;
}

async function pedirOrdenesReceivingMissing(){
    //Pedir Pagos Pendientes de envio. Por ahora, ponemos esto en 0
    return 0;
}

async function pedirCompradores(){
    let compradores = await query (`SELECT * FROM usuarios`);
    let pureCompradores = [];
    for (let i = 0; i < compradores.length; i++){
        let comprador = {id: compradores[i].id, user: compradores[i].user};
        pureCompradores.push(comprador);
    }
    //console.log(pureCompradores);
    return pureCompradores;
}

async function unirInventario(){
    //Calcular el valor del inventario, y ponerlo en un array con item, comprador, precio, stock, total.
    let stock = await pedirStock();
    let compradores = await pedirCompradores();
    let POs = await pedirPOs();
    console.log(`Informacion servida, calculando...`);
    //let costoTotal = 0;

    stock.forEach((product)=> {
        let costoProducto = POs.find(item => item.sku == product.sku);
        if (typeof costoProducto == 'undefined'){
            console.log(`${product.sku} no tiene costo, COSTO 0 REVISAR!!`);
            //console.log(`Para el prod. ${product.sku} el costo es: 0`)
            product.cost = 0;
        }
        else
        {
        //console.log(`Para el prod. ${product.sku} el costo es: ${costoProducto.cost}`)
        product.cost = costoProducto.cost;
        //console.log(`El comprador es: ${costoProducto.comprador}`)
        product.comprador = costoProducto.comprador;
        }
        let datosComprador = compradores.find(buyer => buyer.id == product.comprador);
        if (typeof datosComprador === 'undefined'){
            //console.log(`El user es indefinido. Se usa 666`)
            product.user = 666;
            product.userid = 666;
        }
        else{
            //console.log(`El user es: ${datosComprador.user}`)
            product.userid = datosComprador.id;
        }
        product.total = product.cost * product.cantidad;
        console.log(`Prod: ${product.sku} tiene asignado: ${product.total}`);
    })
    return stock;
}

async function calcularStock(){
    let stock = await unirInventario();
    let buyers = new Set ();
    stock.forEach(product => {
        buyers.add(product.userid);
    })
    buyers = Array.from(buyers); //tengo set con id de compradores.
    buyersStock = []; //Array de compradores y su stock.
    buyers.forEach(buyer => {
        let inHand = {buyerid: buyer, stock: 0}
        stock.forEach(product => {
            if (product.userid == buyer){
                inHand.stock +=product.total;
            }
            
        }) 
        buyersStock.push(inHand);
    });
    buyersStock.forEach(buyer => {
        query(`REPLACE INTO botazonStock (id,lastUpdated,amount) VALUES (${buyer.buyerid},'${new Date().toISOString()}',${buyer.stock})`);
    })
}

module.exports = {calcularStock}
---
| | | | restock.js
//Obtener ventas last 30 days. 
//Calcular promedio 30 D.
//Calcular Promedio 15 D.
//Calcular Promedio 7 D.

const {query} = require('../../basicReq');

async function queryOrdenes(){
    let res = await query(`SELECT * FROM reporte_prueba WHERE confirmed = 1`);
        if (res.length > 0 || res.length != 'undefined'){
            return res;
        }
        else
        {
            console.log('No hay ordenes');
            return 0;
        }
}

async function queryInventory(){
    let res = await query(`SELECT * FROM datos_items`);
    if (res.length > 0 || res.length != 'undefined'){
        return res;
    }
    else
    {
        console.log('No hay items');
        return 0;
    }
}

async function getInventory(){
    let inventory = await queryInventory();
    let cleanInv = []
    if (inventory == 0){
        return 0;
    }
    inventory.forEach(item => {
        let pusheable = {sku: item.sku, quantity: item.afnfulfillablequantity}
        cleanInv.push(pusheable);
    })
    //console.log(cleanInv);
    return cleanInv;
}

var today = new Date();
var last30 = new Date(new Date().setDate(today.getDate() - 30));

async function getOrders(){
    let orders = await queryOrdenes();
    if (orders == 0){ return 0;}
    last30orders = [];
    orders.forEach(order => {
        if (new Date (order.order_date) > last30){
            //console.log(`${new Date(order.order_date).toISOString()} es mayor a ${last30.toISOString()}`)
            last30orders.push(order);
        }
    })
    let skus = new Set ();
    last30orders.forEach(order => {
        skus.add(order.sku);
    })
    //
    skus = Array.from(skus); //tengo set con skus.
    soldOneMonth = []; //Array de skus y su qty, con su comprador.
    skus.forEach(sku => {
        let sold = {sku: sku, sold: 0,comprador: 0}
        last30orders.forEach(order => {
            if (order.sku == sku){
                sold.sold +=order.quantity;
                sold.comprador = order.id_comprador;
            }
        }) 
        soldOneMonth.push(sold);
    });
    //console.log(soldOneMonth); //Todo finalizado.
    return soldOneMonth;
}

async function saveRestock(res){
    await query (`REPLACE INTO datosRestock (sku,sold,comprador,supplierDelay,currentStock,daysInStock) VALUES ('${res.sku}','${res.sold}','${res.comprador}','0','${res.inStock}','${res.days}')`);
}

async function restockCalculator(){
    console.log('RestockCalculator in action')
    //Aca va a ir la funcion que da todo. Para no cambiar routes.
    let lastMonthOrders = await getOrders();
    let currentInventory = await getInventory();
    console.log(`Tengo la primera tanda`)
    let stockNotifications = [];
    currentInventory.forEach(item => {
        let notif = {sku: item.sku, sold: 0,inStock: 0,comprador: 0,days: 0}
        lastMonthOrders.forEach(order => {
            if (item.sku == order.sku){
                notif.comprador = order.comprador;
                notif.sold = order.sold;
                notif.inStock = item.quantity;
                notif.days = Math.floor(item.quantity * 30 / notif.sold);
                //console.log(notif);
                stockNotifications.push(notif);
            }
        })
    })
    console.log(`Guardando restock`);
    await query(`TRUNCATE TABLE datosRestock`);
    for (let i = 0; i < stockNotifications.length; i++) {
        await saveRestock(stockNotifications[i]);
    }
    console.log('done.')
}



module.exports = {restockCalculator}
---
| | | updateInventory.js
//Inventory.js should be able to handle all requests at once, wait, udpate, without the usage of any further files other than includes to subfunctions. 

let sellingPartner  = require (`../sellerApiReq`);

const {query} = require('../basicReq');
const {updateItemInfo} = require('./newUpdateInvInfo')

class item {
  constructor(sku,fnsku,asin,productName,condition,yourprice,afnlistingexists,afnwarehousequantity,afnfulfillablequantity,afnunsellablequantity,afnreservedquantity,afntotalquantity,afnperunitvolume,afninboundworkingquantity,afninboundshippedquantity,afninboundreceivingquantity,afnresearchingquantity){
  this.sku = sku;
  this.fnsku = fnsku;
  this.asin = asin;
  this.productName = productName;
  this.condition = condition;
  this.yourprice = yourprice;
  this.afnlistingexists = afnlistingexists;
  this.afnwarehousequantity = afnwarehousequantity;
  this.afnfulfillablequantity = afnfulfillablequantity;
  this.afnunsellablequantity = afnunsellablequantity;
  this.afnreservedquantity = afnreservedquantity;
  this.afntotalquantity = afntotalquantity;
  this.afnperunitvolume = afnperunitvolume;
  this.afninboundworkingquantity = afninboundworkingquantity;
  this.afninboundshippedquantity = afninboundshippedquantity;
  this.afninboundreceivingquantity = afninboundreceivingquantity;
  this.afnresearchingquantity = afnresearchingquantity;
  this.isEnrolledSL;
  }
};

async function crearReporteAmazon()
{
    try {  
        let res = await sellingPartner.callAPI({
          operation:'createReport',
          endpoint:'reports',
          body:{
        reportType:'GET_FBA_MYI_ALL_INVENTORY_DATA',
        marketplaceIds:['ATVPDKIKX0DER']
      }
    })
      console.log(`El report ID es ${res.reportId}`);
        return res;
      } catch(e){
        console.log(e);
      }
}

async function getReport(id){
  try {
      let report_document = await sellingPartner.callAPI({
    operation:'getReport',
    endpoint:'reports',
    path:{
      reportId: id 
    }
  });
  return (report_document);
    } catch(e){
      console.log(e);
    }
  };

async function getReportDocuments(report){
  try {
    let report_document = await sellingPartner.callAPI({
    operation:'getReportDocument',
    endpoint:'reports',
    path:{
      reportDocumentId: report
    }
  });
  console.log(report_document);
    return (report_document);
    } catch(e){
      console.log(e);
    }
};

async function downloadReport (finalfinal) {
  try {
    let sellingPartner = new SellingPartnerAPI({
      region:'na',
      refresh_token:process.env.AmzToken });
      let report = await sellingPartner.download(finalfinal, {
        json:true,
        });
      //log(report);
      return report;
      } 
      catch(e)
      {
        console.log(e);
      }
};


async function actualizarDB(datos){
  console.log('Arranco a Actualizar...');
  let list = [];
  for (let i = 0; i < datos.length; i++){
    console.log(`item ${i}`);
      sku = datos[i].sku;
      fnsku = datos[i].fnsku;
      asin = datos[i].asin;
      productName = datos[i]['product-name'].replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      condition = datos[i].condition;
      yourprice = datos[i]['your-price'];
      afnlistingexists = datos[i]['afn-listing-exists'];
      afnwarehousequantity = datos[i]['afn-warehouse-quantity'];
      afnfulfillablequantity = datos[i]['afn-fulfillable-quantity'];
      afnunsellablequantity = datos[i]['afn-unsellable-quantity'];
      afnreservedquantity =  datos[i]['afn-reserved-quantity'];
      afntotalquantity = datos[i]['afn-total-quantity'];
      afnperunitvolume = datos[i]['per-unit-volume'];
      afninboundworkingquantity = datos[i]['afn-inbound-working-quantity'];
      afninboundshippedquantity = datos[i]['afn-inbound-shipped-quantity'];
      afninboundreceivingquantity = datos[i]['afn-inbound-receiving-quantity'];
      afnresearchingquantity = datos[i]['afn-researching-quantity'];
      let Producto = new item (sku,fnsku,asin,productName,condition,yourprice,afnlistingexists,afnwarehousequantity,afnfulfillablequantity,afnunsellablequantity,afnreservedquantity,afntotalquantity,afnperunitvolume,afninboundworkingquantity,afninboundshippedquantity,afninboundreceivingquantity,afnresearchingquantity);
      list.push(Producto);
  }
  list.forEach(x => {(async() =>{
    x.isEnrolledSL = await isSL(x.sku);
    console.log(`${x.sku} status${x.isEnrolledSL}`);
    let existencia = await verificarExistencia(x.sku);
    if (existencia)
    await updateRow(x);
    else
    await createRow(x);
  })()    
  })
};

async function isSL(sku){
  try {
    let sellingPartner = new SellingPartnerAPI({
        region:'na', // The region to use for the SP-API endpoints ("eu", "na" or "fe")
        refresh_token:process.env.AmzToken // The refresh token of your app user
      });
  let res = await sellingPartner.callAPI({
    operation:'getSmallAndLightEnrollmentBySellerSKU',
    endpoint:'fbaSmallAndLight',
    path: {sellerSKU: sku},
    query:{marketplaceIds: 'ATVPDKIKX0DER'}
            });
      if (res.status == 'ENROLLED')
      return 1;
      else
      return 0;   
    } catch(e){
      console.log(e);
    }
}

async function updateRow(item){
  console.log(`EXISTE ${item.sku}`);
  await query (`UPDATE datos_items SET fnsku = '${item.fnsku}' ,asin = '${item.asin}', name = '${item.productName}', item_condition = '${item.condition}' , yourprice = '${item.yourprice}' , afnlistingexists = '${item.afnlistingexists}' , afnwarehousequantity = '${item.afnwarehousequantity}' , afnfulfillablequantity = '${item.afnfulfillablequantity}' , afnunsellablequantity = '${item.afnunsellablequantity}' , afnreservedquantity = '${item.afnreservedquantity}' , afntotalquantity = '${item.afntotalquantity}' , perunitvolume = '${item.afnperunitvolume}' , afninboundworkingquantity = '${item.afninboundworkingquantity}' , afninboundshippedquantity = '${item.afninboundshippedquantity}' , afninboundreceivingquantity = '${item.afninboundreceivingquantity}',afnresearchingquantity = '${item.afnresearchingquantity}', isEnrolledSL = '${item.isEnrolledSL}' WHERE sku = '${item.sku}'`);
  console.log(`Contenido de ${item.sku} actualizado.`);
};

async function createRow(item){
  console.log(`NO EXISTE ${item.sku}`);
  await query (`INSERT INTO datos_items (sku,fnsku,asin,name,item_condition,yourprice,afnlistingexists,afnwarehousequantity,afnfulfillablequantity,afnunsellablequantity,afnreservedquantity,afntotalquantity,perunitvolume,afninboundworkingquantity,afninboundshippedquantity,afninboundreceivingquantity,afnresearchingquantity,isEnrolledSL) VALUES ('${item.sku}','${item.fnsku}','${item.asin}','${item.productName}','${item.condition}','${item.yourprice}','${item.afnlistingexists}','${item.afnwarehousequantity}','${item.afnfulfillablequantity}','${item.afnunsellablequantity}','${item.afnreservedquantity}','${item.afntotalquantity}','${item.afnperunitvolume}','${item.afninboundworkingquantity}','${item.afninboundshippedquantity}','${item.afninboundreceivingquantity}','${item.afnresearchingquantity}',${item.isEnrolledSL})`);
  console.log(`Contenido de ${item.sku} agregado.`);
};

async function verificarExistencia(sku) {
  console.log(`Verificar Existencia ${sku}`);
  existencia = await query(`SELECT * FROM datos_items WHERE sku = '${sku}'`);
  if (typeof existencia[0] != 'undefined')
  return true;
  else
  return false;
};

async function updInventory(){
  let finalReport;
  let reportId = await crearReporteAmazon();
  let reportDocument = await getReport(reportId.reportId); //
  let status = reportDocument.processingStatus;
  while ((status == 'IN_QUEUE') || (status == 'IN_PROGRESS')){
    console.log(`Patience, my young padawan. ${reportDocument.processingStatus}`)
    reportDocument = await getReport(reportId.reportId);
    status = reportDocument.processingStatus;
    if (status == 'DONE'){
      break;
      }
      else if (status == 'CANCELLED' || status == 'FATAL'){
        console.log('exploto todo.');
      }
  }
  if (status == 'DONE'){
    let downloadUrl = await getReportDocuments(reportDocument.reportDocumentId);
    finalReport = await downloadReport(downloadUrl);
    await actualizarDB(finalReport);
  }
  else
  {
    if (status == 'IN_PROGRESS' || status == ('IN_QUEUE')){
      console.log(`No deberia estar aca... por que saliste?! Si tu status no era DONE?? ${status}`)
    }
    else
    if (status == 'FATAL' || status == 'CANCELLED'){
      console.log(`Algo salio terriblemente mal. Reporte ${status}`)
    }
  }
  updateItemInfo();
}

module.exports = {updInventory};
---
| orders/
| | | orderHandler.js
/*This should replace the old order script that works like ass. 
Every Day, ask for a createdAfter for the last 2h. 
Every 2 hs. We'll ask for the orders for the last 2 hs. We should get all. And update the rest once we do. We 
*/

let sellingPartner  = require (`../sellerApiReq`);
const {query} = require('../basicReq');


async function crearReporteAmazon(){
    try {  
      let twoHoursBefore = new Date();
    twoHoursBefore.setHours(twoHoursBefore.getHours() - 2);
    let rightNow = new Date();
        let res = await sellingPartner.callAPI({
          operation:'createReport',
          endpoint:'reports',
          body:{
        reportType:'GET_FLAT_FILE_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL',
        dataStartTime: twoHoursBefore.toISOString().slice(0,19) + '+00:00',
        dataEndTime: rightNow.toISOString().slice(0,19) + '+00:00',
        marketplaceIds:['ATVPDKIKX0DER']
        }
    })
    console.log(`El report ID es ${res.reportId}`);
        return res;
      } catch(e){
        console.log(e);
      }
}

async function getReportDocuments(report){
    try {
        let report_document = await sellingPartner.callAPI({
      operation:'getReportDocument',
      endpoint:'reports',
      path:{
        reportDocumentId: report.reportDocumentId // retrieve the reportDocumentId from a "getReport" operation (when processingStatus of report is "DONE")
      }
    });
    console.log(report_document);
        return (report_document);
      } catch(e){
        console.log(e);
      }
};

async function downloadReport (finalfinal) {
  try {
      let report = await sellingPartner.download(finalfinal, {
        json:true,
      });
      console.log(report);
      return report;
      } catch(e){
        console.log(e);
      }
};


class order {
    constructor(order_id,purchase_date,last_updated_date,status,saleschannel,fulfillment,asin,sku,quantity,principal,shipping,tax,shippingtax,promotion,order_total,nro_items,city,state,postal_code,procesado,error,missing_update,precargada,shipCountry,isBusinessOrder){
        this.order_id = order_id;
        this.purchase_date = purchase_date;
        this.last_updated_date = last_updated_date;
        this.status = status;
        this.saleschannel = saleschannel;
        this.fulfillment = fulfillment;
        this.asin = asin;
        this.sku = sku;
        this.quantity = quantity;
        this.principal = principal;
        this.shipping = 0;
        this.tax = 0;
        this.shippingtax = 0;
        this.promotion  = 0;
        this.order_total = order_total;
        this.nro_items = nro_items;
        this.city = city;
        this.state = state;
        this.postal_code = postal_code;
        this.procesado = procesado;
        this.error = error;
        this.missing_update = missing_update;
        this.precargada = precargada;
        this.shipCountry = shipCountry;
        this.isBusinessOrder = isBusinessOrder;

    }
};

async function getReport(id){
    try {
        let report_document = await sellingPartner.callAPI({
      operation:'getReport',
      endpoint:'reports',
      path:{
        reportId: id // retrieve the reportDocumentId from a "getReport" operation (when processingStatus of report is "DONE")
      }
    });
    //log(report_document);
    return (report_document);
      } catch(e){
        console.log(e);
      }
    };

  async function orderHandler(){
  let finalReport;
  let reportId = await crearReporteAmazon();
  let reportDocument = await getReport(reportId.reportId); // - 
  let status = reportDocument.processingStatus;
  while ((status == 'IN_QUEUE') || (status == 'IN_PROGRESS')){
    console.log(`Patience, my young padawan. ${reportDocument.processingStatus}`)
    reportDocument = await getReport(reportId.reportId);
    status = reportDocument.processingStatus;
    if (status == 'DONE'){

      }
      else if (status == 'CANCELLED' || status == 'FATAL'){
        console.log('exploto todo.');
      }
  }
  if (status == 'DONE'){
    let downloadUrl = await getReportDocuments(reportDocument);
    finalReport = await downloadReport(downloadUrl);
  }
  else
  {
    if (status == 'IN_PROGRESS' || status == ('IN_QUEUE')){
      console.log(`No deberia estar aca... por que saliste?! Si tu status no era DONE?? ${status}`)
    }
    else
    if (status == 'FATAL' || status == 'CANCELLED'){
      console.log(`Algo salio terriblemente mal. Reporte ${status}`)
    }
  }
  await actualizarDB(finalReport);
  console.log(`Concluido, ahora me pongo a actualizar pendientes.`);
  await updateOrders();
  console.log ('AHORA SI. Fijate a ver.')
  }
  
  async function actualizarDB(datos){
    console.log('arranco a Actualizar...');
    for (let i = 0; i < datos.length; i++){
      console.log(`Order ${i}: ${datos[i]['amazon-order-id']}`);
        order_id = datos[i]['amazon-order-id'];
        purchase_date = datos[i]['purchase-date'];
        last_updated_date = datos[i]['last-updated-date'];
        elstatus = datos[i]['order-status'];
        saleschannel = datos[i]['sales-channel'];
        fulfillment = datos[i]['fulfillment-channel'];
        asin = datos[i]['asin'];
        sku = datos[i]['sku'];
        quantity = datos[i]['quantity'];
        principal = datos[i]['item-price'] / datos[i]['quantity'];
        shipping = 0;
        tax = 0;
        shippingtax = 0;
        promotion  = 0;
        order_total = datos[i]['item-price'];
        nro_items = 1;
        city = datos[i]['ship-city'].replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        state = datos[i]['ship-state'].replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        postal_code = datos[i]['ship-postal-code'].replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        procesado = 0;
        error = 0;
        missing_update = 1;
        precargada = 0;
        shipCountry = datos[i]['ship-country'].replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        isBusinessOrder = datos[i]['is-business-order'];
        let producto = new order(order_id,purchase_date,last_updated_date,elstatus,saleschannel,fulfillment,asin,sku,quantity,principal,shipping,tax,shippingtax,promotion,order_total,nro_items,city,state,postal_code,procesado,error,missing_update,precargada,shipCountry,isBusinessOrder);

            await createRow(producto);
    }
    
};


async function createRow(producto){
  console.log(`Agreagando orden ${producto.order_id}`);
    await query (`INSERT INTO datos_ordenes (order_id,purchase_date,last_updated_date,status,saleschannel,fulfillment,asin,sku,quantity,principal,shipping,tax,shippingtax,promotion,order_total,nro_items,city,state,postalcode,procesado,error,missing_update,precargada,shipCountry,isBusinessOrder) VALUES ('${producto.order_id}','${producto.purchase_date}','${producto.last_updated_date}','${producto.status}','${producto.saleschannel}','${producto.fulfillment}','${producto.asin}','${producto.sku}','${producto.quantity}','${producto.principal}','${producto.shipping}','${producto.tax}','${producto.shippingtax}','${producto.promotion}','${producto.order_total}','${producto.nro_items}','${producto.city}','${producto.state}','${producto.postal_code}','${producto.procesado}','${producto.error}','${producto.missing_update}','${producto.precargada}','${producto.shipCountry}','${producto.isBusinessOrder==true?1:0}')`);
    console.log(`Contenido de ${producto.order_id} agregado.`);
};

function chunk (arr, len) {
    let chunks = [],
        i = 0,
        n = arr.length;
    while (i < n) {
      chunks.push(arr.slice(i, i += len));
    }
    console.log(chunks);
    return chunks;
  }

  async function atraparPendientes(){
    let res = await query(`SELECT * FROM datos_ordenes WHERE status = 'Pending'`);
      var orderList = new Set();
      let i = 0;
      while (i < res.length) {
          orderList.add(res[i].order_id);
          i++;
          }
      if (i> 0)
      console.log(`Las ordenes son: ${orderList}`);
      else
      console.log('No hay ordenes pendientes');
      return Array.from(orderList);
      }

async function updateOrders(){
    let res = await atraparPendientes();
    if (res.length > 0){
      console.log(`Actualizando...`)
      await actualizarPendientes(res);
    }
    else
    {
      console.log (`Nada para actualizar...`)
    }
}

async function getOrders(list){
  let res = await sellingPartner.callAPI({
    operation:'getOrders',
    endpoint:'orders',
    query:{
                MarketplaceIds: 'ATVPDKIKX0DER',
                AmazonOrderIds: list
              }
});
return res;
}

async function escribirDB(orderId,status){
  // If block
  if(status == "Shipped")  {
      //Actualizamos el estado en los datos_ordenes y actualizamos a confirmado (1) el profit en reporte_prueba.
      await query(`UPDATE datos_ordenes SET status = '${status}' WHERE order_id = '${orderId}'`)
      console.log(`Status actualizado a ${status} : Shipped. OK`);
      await query(`UPDATE reporte_prueba SET confirmed = 1 WHERE order_id = '${orderId}'`);
      console.log("Profit actualizado. OK");
      return true;  
  }
  // else if block
  else if (status == "Canceled") {
    //Actualizamos el estado en los datos_ordenes y actualizamos a cancelado (2) el profit en reporte_prueba.
    await query(`UPDATE datos_ordenes SET status = '${status}' WHERE order_id = '${orderId}'`)
    console.log(`Status actualizado a ${status} : Canceled. OK`)
    await query(`UPDATE reporte_prueba SET confirmed = 2 WHERE order_id = '${orderId}'`)
    console.log("Profit actualizado. OK")
    return true;  
  }
  else if (status == "Pending") {
    //No hace nada!.
    //await query(`UPDATE reporte_prueba SET confirmed = 0 WHERE order_id = '${order_id}'`);
    //await query( `UPDATE datos_ordenes SET status = 'Pending_Tmp' WHERE order_id = '${order_id}'`);
    console.log("Orden pendiente, no se hace nada.");
    return true;
  }  
  else {
    console.log ('Error catastrofico');
  }
}
      
async function actualizarPendientes(orderList){   
  if (orderList.length > 0) {
    let listas;
    let single;
    if (orderList.length > 50){ //Si las ordenes son mas de 50 hago packs.
      listas = chunk(orderList,50);
      console.log(listas);
    }
    else
      single = true; //Mando una sola tirada.
      console.log(`Las ${orderList.length} ordenes a procesar son: ${orderList}`);
      let orderListFinal = [];
      if (single){ //Si es una sola, tiro una por una a actualizar.
        orderListFinal = await getOrders(orderList);
        console.log(`Only 1 set`);
        console.log(orderListFinal.length);
        for (let i=0; i < orderListFinal.Orders.length; i++){
          console.log(`Order Length es ${orderListFinal.Orders.length}`)
          let order_id = orderListFinal.Orders[i].AmazonOrderId;
          let status = orderListFinal.Orders[i].OrderStatus;
          console.log(order_id);
          console.log(status);
          if (!await escribirDB(order_id,status))
            console.log(`Error de escritura en DB`); //Mando a escribir.
        }
      }
      else //Hay mas de 50, a kilombear todo.
      {
      for (let i = 0; i < listas.length; i++){
        let res = await getOrders(listas[i]);
        orderListFinal.push(res);
        console.log(`OrderListFinal, ahora es: ` + orderListFinal)
      }
      console.log(orderListFinal.length);
      for (let t = 0; t < orderListFinal.length; t++){
        console.log(`Vuelta Numero ${t}`);
        for (let i=0; i < orderListFinal[t].Orders.length; i++){
          console.log(`Order Length for t i es ${orderListFinal[t].Orders.length}`)
          let order_id = orderListFinal[t].Orders[i].AmazonOrderId;
          let status = orderListFinal[t].Orders[i].OrderStatus;
          console.log(order_id);
          console.log(status);
          if (!await escribirDB(order_id,status))
            console.log(`Error de escritura en DB`)
          }
      }
}
}
else
{
  console.log(`No hay ordenes`);
}        
}


module.exports = {orderHandler}


---
| | | profitCalculator.js
//getMyFeesEstimateForSKU

let sellingPartner  = require (`../sellerApiReq`);
const {query} = require('../basicReq');


class orderProfit {
    constructor(sku,order_id,cost,quantity,pv,sandl,orderDate,feesDate,idComprador,sales_channel,errr){
        this.sku = sku;
        this.order_id = order_id;
        this.cost = cost;
        this.quantity = quantity;
        this.sandl = sandl;
        this.sales_channel = sales_channel;
        this.pv = pv;
        this.fee;
        this.ganancia;
        this.orderDate = orderDate;
        this.feesDate = feesDate;
        this.idComprador = idComprador;
        this.errr = errr;
        this.procesado = 0;
    }
    
}

async function queryDatosOrdenes(){
    let res = await query(`SELECT * FROM datos_ordenes WHERE status = 'Shipped' AND procesado = '0'`);
        if (res?.length > 0 || res?.length != 'undefined'){
            return res;
        }
        else
        {
            console.log('No hay skus pendientes');
            return 0;
        }
}

async function queryDatosPOs(){
    let res = await query(`SELECT * FROM datos_pos WHERE active = '1'`);
    // cantidad de resultados
        if (res?.length > 0 || res?.length != 'undefined'){
            return res;
        }
        else
        {
            console.log('No hay POs Activas');
            return 0;
        }
}

async function queryInventory(){
    let res = await query(`SELECT * FROM datos_items`);
        if (res?.length > 0 || res?.length != 'undefined'){
            return res;
        }
        
        else
        {
            console.log('No hay items en Inventory');
            return 0;
        }
}

async function calcularFee(id){
    console.log(`Enviando SKU: ${id.sku}, de precio ${id.precio} y SNL = ${id.ofc}`);
    if (id.ofc)
    ofc = 'FBA_SNL';
    else
    ofc = 'FBA_CORE';
    let res = await sellingPartner.callAPI({
        operation:'getMyFeesEstimateForSKU',
        endpoint:'productFees',
        body:{
            FeesEstimateRequest: {
                MarketplaceId: 'ATVPDKIKX0DER',
                IsAmazonFulfilled: true,
                PriceToEstimateFees:{
                ListingPrice:{
                    Amount: id.precio,
                    CurrencyCode: 'USD',
                },
                },
                Identifier: id.sku,
                OptionalFulfillmentProgram: ofc
                }
            },
                
        path: {
                SellerSKU: id.sku
                }
                }
);
    //log(res);
    if (res.message == 'Too Many Requests'){
        console.log(`Recalculando`)
        res = await calcularFee(id);
    }
            
    //console.table(res.FeesEstimateResult.FeesEstimate.FeeDetailList[3].IncludedFeeDetailList)
    if (typeof res?.FeesEstimateResult?.FeesEstimate !== 'undefined')
    return res?.FeesEstimateResult?.FeesEstimate?.TotalFeesEstimate?.Amount;
    else
    return 0;
    }

async function groupie(){
    let v1 = await queryDatosOrdenes();
    let v2 = await queryDatosPOs();
    let v3 = await queryInventory()
    
    let vtotal = await mergeItems(v1, v2, v3);
    /*  tengo items mergeados. Ahora necesito mapear la lista para calcular fees con Promise.all()
        let vtotalcfees = await Promise.all(vtotal.map(async (item) => {
            let id = {sku: item.sku, precio : item.pv, ofc : item.sandl};
            let fee = await calcularFee(id);
            item.fee = fee;
            item.ganancia = item.pv - fee - item.cost;
            return item;
        }))*/
    if (vtotal != 0){
        //Necesito hacer una lista de calculos, sin duplicados. Para eso, agrego el primero, y si el segundo es el mismo que el primero, en $$ y SKU,
        //entonces no lo agrego. Pero como comparo todo? 
        let listaParaProcesar = [];
        for (let i = 0; i < vtotal.length; i++){
            let id = {sku:vtotal[i].sku,precio: vtotal[i].pv, ofc: vtotal[i].sandl,fee: 0};
            listaParaProcesar.push(id);
        }
        listaParaProcesar = listaParaProcesar.filter((value, index, self) =>
        index === self.findIndex((t) => (
        t.sku === value.sku && t.pv === value.pv
  ))
)
console.log(listaParaProcesar)
        
        /*vtotalcfees = await Promise.all(listaParaProcesar.map(async (item) => {
            let fee = await calcularFee(item);
            item.fee = fee;
            //item.ganancia = item.pv - fee - item.cost;
            return item;
        }))
*/
        for (let i = 0; i < listaParaProcesar.length; i++)
        {
            //console.log(`Procesando ${listaParaProcesar[i].sku}, la concha de la lora item numero ${i}`)
            listaParaProcesar[i].fee = await calcularFee(listaParaProcesar[i]);
            if (listaParaProcesar[i].fee == 0){
                console.log(`NO ANDA EL FEEEEEEEEEEEEEEEEEEE`)
            }else
            console.log(`El fee es de: ${listaParaProcesar[i].fee}`)
        }
        vtotalcfees = listaParaProcesar;
        //console.log(vtotal);
        //Ahora uno de nuevo la lista vtotal con los procesados (vcfees)
        for (let i = 0; i < vtotal.length; i++){
            for (let j = 0; j < vtotalcfees.length; j++){
                if (vtotal[i].sku == vtotalcfees[j].sku && vtotal[i].pv == vtotalcfees[j].precio)
                {
                    vtotal[i].fee = vtotalcfees[j].fee;
                    if (vtotalcfees[j].fees !== 0)
                    vtotal[i].ganancia = vtotal[i].pv - vtotal[i].cost - vtotal[i].fee;
                    else
                    vtotal[i].ganancia = 0;
                }
            }
        }
        console.log(`Nuevo VTOTAL! `)
        //console.table(vtotal)
        return vtotal;
        
        /* 
                // tengo items mergeados. Ahora necesito mapear la lista para calcular fees con Promise.all()
               let vtotalcfees = await Promise.all(vtotal.map(async (item) => {
                    let id = {sku: item.sku, precio : item.pv, ofc : item.sandl};
                    let fee = await calcularFee(id);
                    item.fee = fee;
                    item.ganancia = item.pv - fee - item.cost;
                    return item;
                }))
                return vtotalcfees;
    */
   }
    else
    {
        console.log(`Hubo un error procesando mergeItems.`)
        return 0;
    }
}

async function mergeItems(ordenes,pos,inventory){
    //Necesito unir POs y Inventory, para hacer POs con SL.
    //Si cualquiera es erroneo, entonces cortamos y devolvemos 0.
    if ((typeof ordenes.length == 'undefined' || typeof pos.length == 'undefined' || typeof inventory.length == 0) || (( ordenes.length == 0 ||  pos.length == 0 || inventory.length == 0)))
    {console.log(`Hay al menos uno de los 3 que no esta definido. No puedo trabajar asi. RENUNCIO! (?`);
    console.log(`INV: ${inventory.length}, POS: ${pos.length}, ORDENES: ${ordenes.length}`);
    return 0;}
    else
    {
        let errr;
        let merged = [];
        for (var i = 0; i < ordenes.length; i++){
            let conversion = 1;
            let order_id = ordenes[i].order_id;
            console.log(`Procesando ${order_id}`);
            let sku = ordenes[i].sku;
            let saleschannel = ordenes[i].saleschannel;
            if (saleschannel == 'Amazon.com.mx'){
                let res = await query(`SELECT * FROM config WHERE id = 1`);
                conversion = res[0].mxn_to_usd * 0.97 ;
                if (typeof conversion == 'undefined')
                console.log(`La cagamo con la conversion 1 eh.`);
            }
            else if(saleschannel == 'Amazon.ca'){
                let res = await query(`SELECT * FROM config WHERE id = 1`);
                conversion = res[0].cad_to_usd * 0.97;
                if (typeof conversion == 'undefined')
                console.log(`La cagamo con la conversion 2 eh.`);
            }
            else if (saleschannel !== 'Amazon.com' && saleschannel !== 'Amazon.com.mx' && saleschannel !== 'Amazon.ca'){
                errr = true;
                console.log(`Esta orden, ${saleschannel}, no es procesable.`)
            }
            let pv = ordenes[i].principal * conversion;
            let quantity = ordenes[i].quantity;
            let orderDate = ordenes[i].purchase_date;
            let feesDate = new Date().toISOString().slice(0,19) + '+00:00'
            let cost = 0; //POs
            let sandl; //INVENTORY
            let fee; // CALCULO
            let ganancia; //CALCULO
            let idComprador; //POs
            errr = false;
            for (let j = 0; j < pos.length; j++) {
                if (sku == pos[j].sku){
                     cost = pos[j].total_cost;
                     idComprador = pos[j].buyer_id;
                     //break;
                }
                else
                {
                    if (j == pos.length -1 && cost == 0){
                        console.log(`Hubo un error: No se encontro item activo con SKU: ${sku}`);
                        errr = true;
                    }
                }
            for (let j = 0; j<inventory.length;j++){
                if (sku == inventory[j].sku){
                    sandl = inventory[j].isEnrolledSL;
                    //break;
                }
                else
                if (j == pos.length-1 && sandl == 'undefined')
                {console.log(`Hubo un error: No se encontro en Inventory el SKU: ${sku}`);
                 errr = true;}
            }   
            }
            //Ahora tenemos todo el item, casi llenito, falta fee y ganancia! Si no hay error...
            if (!errr){
            let ofc;
            if (sandl)
            ofc = 'FBA_SNL';
            else
            ofc = 'FBA_CORE';
            //let id = {sku: sku, precio : pv, ofc : ofc};
            //fee = await calcularFee(id);
            //ganancia = pv - fee - cost;
            let temp = new orderProfit(sku,order_id,cost,quantity,pv,/*fee,*/sandl,/*ganancia,*/orderDate,feesDate,idComprador,saleschannel,errr);
            //log(`Orden: ${temp.order_id} dio profit: ${temp.ganancia}`)
            merged.push(temp);
            }
            else
            {
                console.log(`Capturado error: ${errr} para Order: ${order_id} de SKU: ${sku}`);
            }
        }
        
        return merged;
    }

}

async function actualizarDB(id){
    if (typeof id.order_id === 'undefined' || id.errr){
        console.log(`No se que hace aca, me voy`);
        return 0;
    }
    else
    {
        await query(`INSERT INTO reporte_prueba (id_comprador,order_id,order_date,fees_date,sku,quantity,principal,fees,cost,ganancia,refunded,replaced,confirmed) VALUES ('${id.idComprador}','${id.order_id}','${id.orderDate}','${id.feesDate}','${id.sku}','${id.quantity}','${!isNaN(id.pv)||id.pv?id.pv:0}','${id.fee?id.fee:0}','${id.cost?id.cost:0}','${id.ganancia?id.ganancia:0}',0,0,1)`);
        await query(`UPDATE datos_ordenes SET procesado = 1 WHERE order_id = '${id.order_id}' AND sku = '${id.sku}'`);
        console.log(`DB Actualizada.`);
        return true;
    }
    
}


async function profitCalc(){

    let itemList = await groupie();
    
    if (itemList == 0){
        return 0;
    }
   for (let i = 0; i < itemList.length; i++) {
    console.log(`Actualizando ${itemList[i].order_id}`);
        if (itemList[i].errr)
        console.log('lidiaremos con esto despues')
        else
        {
            let t = await actualizarDB(itemList[i]);
            if (!t){
                console.log(`ERRORRRRRRRRRR WIU WIU WIU `)
            }
        }

        console.log(`El profit de ${i} se ha actualizado.`);
        
        }
        console.log(`Concluido todo.`)             
}

module.exports = {profitCalc};

//calcularFee({sku:'GIT00000869',precio:9.99,ofc:'FBA_SNL'})
---
| | | profitCalculator2.js
//getMyFeesEstimateForSKU

let sellingPartner = require(`../sellerApiReq`);
const { query } = require("../basicReq");

async function getOrdersFromDB() {
  let res = await query(
    `SELECT * FROM datos_ordenes WHERE status = 'Shipped' AND procesado = '0'`
  );
  if (res?.length > 0 || res?.length != "undefined") {
    return res;
  } else {
    console.log("No hay skus pendientes");
    return 0;
  }
}

async function getPOsFromDB() {
  let res = await query(`SELECT * FROM datos_pos WHERE active = '1'`);
  // cantidad de resultados
  if (res?.length > 0 || res?.length != "undefined") {
    return res;
  } else {
    console.log("No hay POs Activas");
    return 0;
  }
}

async function getInventoryFromDB() {
  let res = await query(`SELECT * FROM datos_items`);
  if (res?.length > 0 || res?.length != "undefined") {
    return res;
  } else {
    console.log("No hay items en Inventory");
    return 0;
  }
}

async function agruparInformacion(){
    let orders = await getOrdersFromDB();
    let pos = await getPOsFromDB();
    let inventory = await getInventoryFromDB();

    let listaDeOrdenes = [];
    /*
    Necesito: 
    A cada orden, ponerla en un campo. La orden tiene: 
    this.sku = sku; <- De orders
    this.order_id = order_id; <- De orders
    this.cost = cost; <- De POs
    this.quantity = quantity; <- De orders
    this.sandl = sandl; <- De Inventory
    this.sales_channel = sales_channel; <- De orders
    this.pv = pv; <- De orders
    this.fee; <- AUTO
    this.ganancia; <- AUTO
    this.orderDate = orderDate; <- De orders
    this.feesDate = feesDate; <- AUTO
    this.idComprador = idComprador; <- De POs
    this.errr = errr; <- Auto
    this.procesado = 0; <- Auto
    */
   let basicModel = {};
    orders.forEach(order =>{
        basicModel.sku = order.sku;
        basicModel.order_id = order.order_id;
        basicModel.quantity = order.quantity;
        basicModel.sales_channel = order.sales_channel;
        basicModel.pv = order.pv;
        basicModel.orderDate = order.orderDate;
    })
}

class OrderProfit {
  constructor(
    sku,
    order_id,
    cost,
    quantity,
    pv,
    sandl,
    orderDate,
    feesDate,
    idComprador,
    sales_channel,
    errr
  ) {
    this.sku = sku;
    this.order_id = order_id;
    this.cost = cost;
    this.quantity = quantity;
    this.sandl = sandl;
    this.sales_channel = sales_channel;
    this.pv = pv;
    this.fee;
    this.ganancia;
    this.orderDate = orderDate;
    this.feesDate = feesDate;
    this.idComprador = idComprador;
    this.errr = errr;
    this.procesado = 0;
  }
  async saveOrder() {}

  async calculateOrder() {
    if (!(this.sku || this.cost || this.quantity || this.pv || this.errr )){
        errr = true;
        console.log('Error en algun campo! ')
        return 0;
    }
    console.log(
      `Enviando SKU: ${this.sku}, de precio ${this.pv} y SNL = ${this.sandl}`
    );
    let ofc;
    if (this.sandl) ofc = "FBA_SNL";
    else ofc = "FBA_CORE";
    let res = await sellingPartner.callAPI({
      operation: "getMyFeesEstimateForSKU",
      endpoint: "productFees",
      body: {
        FeesEstimateRequest: {
          MarketplaceId: "ATVPDKIKX0DER",
          IsAmazonFulfilled: true,
          PriceToEstimateFees: {
            ListingPrice: {
              Amount: this.pv,
              CurrencyCode: "USD",
            },
          },
          Identifier: this.sku,
          OptionalFulfillmentProgram: ofc,
        },
      },

      path: {
        SellerSKU: this.sku,
      },
    });
    //log(res);
    if (res.message == "Too Many Requests") {
      console.log(`Recalculando`);
      res = await this.calculateOrder();
    }

    //console.table(res.FeesEstimateResult.FeesEstimate.FeeDetailList[3].IncludedFeeDetailList)
    if (typeof res?.FeesEstimateResult?.FeesEstimate !== "undefined"){
      this.fee =  res?.FeesEstimateResult?.FeesEstimate?.TotalFeesEstimate?.Amount;
      this.ganancia = this.pv - this.fee - this.cost;
      }
    else 
      this.err = true;
  }
}

---
| pos/
| prices/
| | | repricer.js
/*    

CAMBIO DE PLANES! 

La clase Repricer main super pro OP, va a ser un conglomerado de items que se estan repriceando. Cada una actua como un independiente, se manejan solitas para intentar evitar errores externos. 

La clase Repricer solamente comanda logicas dentro del repricer solo. EJ: 
Tiene 50 items activos, 300 inactivos.
Corre los 50, luego los 300.
Cuando termine, solamente agrega a activos / inactivos y actualiza activos. El cambio es por DB.

Cuando termina de dar vuelta los activos, vuelve a preguntar, y vuelve a empezar. Va a ser re intenso con "Repricer Help" via Telegram. Asi que voy a tener que ver algo para evitar enviar la MISMA notificacion dos veces. 

Si la notif. es igual a la anterior que se envio hace mas de 2h, no reenviar?

*/
const RepricerLogic = require('./repricerClasses')
const fs = require('fs');
const {query} = require('../basicReq')

async function log(msg){
    console.log(msg);
}

class Repricer {
    constructor(){
        this.activeSKUs = []; //live Skus.
        this.inactiveSKUs = [];//Skus that have no stock
        this.skusOwners = [];
        this.notificationLog = [];
        this.notifsSent = [];
        this.reviewNotifs = [];
    }
    async setup(){
        //Alta de items. Unica vez.
        await this.writeOwners();//Primera vuelta de escribir duenios.
        console.log(`Duenios done.`)
        await this.writeSkus();//Primera vuelta de SKUs.
        console.log(`SKUs agregados`);
        this.run();
        return true;
    }

    addNewNotif(notif) {
        this.notificationLog.push({notif:notif,date:new Date()})
        console.log(notif.myOffer,'y price',notif.price,'en ',notif.sku);
        if (notif.myOffer == notif.price)
        return 0;
        if (this.reviewNotifs.length > 0)
        this.reviewNotifs = this.reviewNotifs.filter(notifi => notif.sku != notifi.sku);
        this.reviewNotifs.push({sku: notif.sku,notif:notif});
    }

    returnNotifs (active = false){
        if (active){
            return this.reviewNotifs.filter(notif => notif.notif.active );
        }
        return this.reviewNotifs;
    }

    returnAllNotifs(){
        return this.notificationLog;
    }

    async run(){
        let runs = 0;
        setInterval(async ()=>{
            runs++; 
            //Ever running.
            //On every loop, we will be cleaning old notifs. 
            //Update active - inactive.
            await this.updateSKUs();
            await this.runActive(true);
            await this.runActive(false);
        },1000* 60 * 15)
          
        }

    async writeOwners(){
        //once a day. 
        let itemOwners = await query(`SELECT * FROM datos_costos`);
        let newOwners = [];
        itemOwners.forEach(item => {
            newOwners.push({sku: item.sku,owner:item.buyerId});
        })
        this.skuOwners = newOwners;
    }

    async writeSkus(){
        //Writes down the SKUs. First time.
        let items = await query(`SELECT * FROM datos_items WHERE ignorar = 0`);
        let active = [];
        let inactive = [];
        items.forEach(item =>{
            if (item.afntotalquantity > 0)
                active.push(item.sku);
            else
                inactive.push(item.sku);
        })
        active.forEach(item => {
            this.activeSKUs.push(new RepricerLogic(item));
        })
        inactive.forEach(item => {
            this.inactiveSKUs.push(new RepricerLogic(item))
        })
        console.log(`WriteDown cleared.`)
        for (let item of this.activeSKUs) {
            let value = await item.limitsAndCompetition();
            if (value != -1){
                value.active = true;
                value.date = new Date()
                this.addNewNotif(value);
            }
        }/*
        for (let item of this.inactiveSKUs){
            let value = await item.limitsAndCompetition();
            if (value != -1){
                value.active = true;
                value.date = new Date()
                this.addNewNotif(value);
            }
        }*/
        console.log('All set');
        return true;
    }

    async updateSKUs(){
        let items = await query(`SELECT * FROM datos_items WHERE ignorar = 0`);
        let active = [];
        let inactive = [];
        items.forEach(item =>{
            if (item.afntotalquantity > 0)
                active.push(item.sku);
            else
                inactive.push(item.sku);
        })
        inactive.forEach(inactiveItem=>{ //busca inactivos en el array de activos.
            let indexOfObject = this.activeSKUs.findIndex(obj => {
                return obj.sku === inactiveItem.sku
            })
            if (indexOfObject){//Si encuentra, lo saca, y agrega a inactivos.
               this.activeSKUs.splice(indexOfObject,1)
               this.inactiveSKUs.push(new RepricerLogic (inactiveItem.sku))
            }
        })
        active.forEach(activeItem => {//Busca en la lista de inactivos items activos.
            let indexOfObject = this.inactiveSKUs.findIndex(obj => {
                return obj.sku === activeItem.sku
            })
            if (indexOfObject){//Si encuentra, lo saca, y agrega a activos.
               this.inactiveSKUs.splice(indexOfObject,1)
               this.activeSKUs.push(new RepricerLogic (activeItem.sku))
            }
        })
        return true;
    }

    async runActive(activos){
        if (activos){
            this.activeSKUs.forEach(one =>{
                one.limitsAndCompetition().then(value =>{
                    this.addNewNotif({notif: value,active:true,sku:value.sku,date:new Date(),myOffer: one.myOffer});
                });            
            })
        }
        else
        {
            this.inactiveSKUs.forEach(one =>{
                one.limitsAndCompetition().then(value =>{
                    this.addNewNotif({notif: value,active:false,sku:value.sku,date:new Date(),myOffer: one.myOffer})
                })
            });
        }
    }
}


module.exports = Repricer;
---
| | | repricerClasses.js
//The infamous Repricer class. This should handle all the logic for the repricer. Should receive a bunch of data and
//suggest the best price. Eventually, change it.
//It should access the "repricer" table for decision making.

const { query } = require("../basicReq");
let sellingPartner = require(`../sellerApiReq`);

class RepricerLogic {
  constructor(_sku) {
    this.sku = _sku;
    this.cero;
    this.map;
    this.userDefinedPrice;
    this.percentageUp = false;
    this.percentageDown = false;
    this.priceUp = false;
    this.priceDown = false;
    this.repricerOff;
  }
  async setMeUp() {
    let cero = await this.getCero(this.sku);
    if (cero != false) {
      await this.getAllInfoFromDB();
      return true;
    } else {
      this.repricerOff = true;
      return false;
    }
  }

  async getCompetitors() {
    try {
      let res = await sellingPartner.callAPI({
        operation: "getListingOffers",
        endpoint: "productPricing",
        path: {
          SellerSKU: [this.sku],
        },
        query: {
          ItemCondition: "New",
          MarketplaceId: 'ATVPDKIKX0DER',
        },
      });
      /*console.log(`LOWEST PRICES: ${res.Summary?.LowestPrices?.length}`);
      res.Summary?.LowestPrices?.forEach((price) => {
        console.log(
          `Price: ${price.LandedPrice?.Amount} from an ${
            price.fulfillmentChannel == "Amazon"
              ? "FBA"
              : price.fulfillmentChannel == "Merchant"
              ? "FBM"
              : "Unknown"
          } seller`
        );
      });*/
      /*console.log(`BUYBOX PRICES: `);
      res.Summary?.BuyBoxPrices?.forEach((price) => {
        console.log(
          `Price: ${price.LandedPrice?.Amount} from an ${
            price.fulfillmentChannel == "Amazon"
              ? "FBA"
              : price.fulfillmentChannel == "Merchant"
              ? "FBM"
              : "Unknown"
          } seller`
        );
      });*/
      let competitors = [];
      res.Summary?.LowestPrices?.forEach((price) => {
        let aux = {
          price: price.LandedPrice.Amount,
          fba: price.fulfillmentChannel == "Amazon" ? true : price.fulfillmentChannel == "Merchant" ? false : "Unknown",
        };
        competitors.push(aux);
      });
      let holder;
      let buybox = res.Summary?.BuyBoxPrices[0]?.LandedPrice?.Amount;
      competitors.forEach(one =>{
        if (one.price == buybox){
            one.fba? holder = 'FBA': holder = false;
        }
      })
      let miOferta;
      res.Offers.forEach(offer => {
        if (offer.MyOffer)
          miOferta = offer.ListingPrice.Amount;
      });
      return { competitors: competitors, buybox: buybox,holder: holder,myOffer:miOferta};
      /*
        console.log(`SALES RANKINGS: `)
        res.Summary?.SalesRankings?.forEach(rank => {
            console.log(`ID: ${rank.ProductCategoryId}, Rank: ${rank.Rank}`);
        })*/
    } catch (err) {
        if (err.code == 'InvalidInput'){
            console.log(`Posiblemente el sku ${this.sku} ya no exista. Lo voy a ignorar`);
            await query(`UPDATE datos_items SET ignorar = 1 WHERE sku='${this.sku}'`);

        }
        return -1
    }
  }

  /*    async lastSales(){
        let res = await query(`SELECT * FROM datosRestock WHERE sku='${this.sku}'`)
        if (res[0]?.sold >= 0 && res[0]?.currentStock > 0){ 
            this.lastThirtyDaySales =  res[0]?.sold;
        }
        if (res[0]?.currentStock == 0){ 
            this.inStock = false;
        }
        return true;
    }
*/

  async getAllInfoFromDB() {
    let res = await query(`SELECT * FROM repricer WHERE sku = '${this.sku}'`);
    this.map = res[0]?.map;
    if (!this.map) this.map = false;
    this.userDefinedPrice = parseFloat(res[0]?.userDefinedPrice);
    if (!this.userDefinedPrice) this.userDefinedPrice = false;
    this.percentageUp = parseFloat(res[0]?.percentageUp);
    if (!this.percentageUp) this.percentageUp = false;
    this.percentageDown = parseFloat(res[0]?.percentageDown);
    if (!this.percentageDown) this.percentageDown = false;
    this.priceUp = parseFloat(res[0]?.priceUp);
    if (!this.priceUp) this.priceUp = false;
    this.priceDown = parseFloat(res[0]?.priceDown);
    if (!this.priceDown) this.priceDown = false;
    //this.lastSales();
  }

  async getCero() {
    /* 
        Intenta buscar un cero calculado. Si no lo encuentra, pide el calculo y recibe.
        Y si aun no recibe su info, apaga el repricer para no mandarse cagadas.
        */
    let cero = await query(
      `SELECT * FROM datos_costos WHERE sku='${this.sku}'`
    );
    cero = cero[0]?.cero;
    //console.log(await query(`SELECT * FROM datos_costos WHERE sku='${this.sku}'`))
    if (cero !== undefined) {
      this.cero = parseFloat(cero);
      return true;
    }
    return false;
  }

  /* =================================================================
    ESENCIA DE FUNCIONAMIENTO DEL SCRIPT.
    El MAP, es la ley. No se baja a menos que se apague. Se apaga solamente si se le pide. 
    Este script no da de alta items (aun) pero lo hara. La idea no es dar de alta, es calcular precios basados en la info que tenemos.
    Para la alta, se hara otro pedazo de soft.
    ORDEN DE PRIORIDADES: 
    MAP (es la primer orden del dia. Si el MAP prohibe bajar, no importa nada)
    USER DEFINED PRICE. Es el precio propuesto por el usuario. "Manual". NO HACE NADA. Solo MAP.
    Automatic repricer. Si userDef no esta definido, y el MAP le permite, juega a subir y bajar (no menos que el map).
    Referencias: Buybox (que te da amz), competition, (que sacamos), ventas (que nos determina si deberiamos bajar), precio/porc (que dice, onda, cuanto podemos sub/baj).
    ================================================================== */

  async suggestedLimits() {
    await this.setMeUp();
    let reason = "";
    function c(num) {
      //cleaner.
      return parseFloat(parseFloat(num).toFixed(2));
    }
    let minimumSoFar = 0;
    let maxSoFar = 0;
    if (!this.cero || this.cero == []) {
      reason += ` NO HAY CERO! Repricer off`;
      return {
        repricerOff: true,
        myOffer: undefined,
        reason: reason,
        sku: this.sku
      };
    }
    if (this.repricerOff) {
      return {
        repricerOff: true,
        myOffer: undefined,
        reason: ` Repricer is off. Please set up all the variables.`,
        sku: this.sku
      };
    }
    if (this.map !== false) {
      minimumSoFar = this.map;
      reason += ` Hay MAP! \n`;
    }
    if (this.userDefinedPrice) {
      //Si esta en manual, solo chequeo el MAP.
      return {
        repricerOff: false,
        myOffer: undefined,
        sku: this.sku,
        minimo:
          this.userDefinedPrice > minimumSoFar
            ? c(this.userDefinedPrice)
            : c(minimumSoFar),
        maximo:
          this.userDefinedPrice > minimumSoFar
            ? c(this.userDefinedPrice)
            : c(minimumSoFar),
        reason:
          reason +
          `Precio manual ${c(this.userDefinedPrice)} vs map ${c(this.map)}`,
        cero: c(this.cero),
      };
    } //Si no está seteado en Manual, vamos a ver que podemos hacer..

    if (this.cero > minimumSoFar) {
      //El cero es mayor que el MAP. Pongo el cero.
      minimumSoFar = this.cero;
      reason += ` El cero es mayor al MAP (si hay)\n`;
    }
    if (this.percentageUp && !this.priceUp) {
      //Si esta seteado solo por %
      maxSoFar = (this.cero * (this.percentageUp + 100)) / 100;
      reason += ` El maximo es porcentaje alto ${this.percentageUp}%`;
    } else if (!this.percentageUp && this.priceUp) {
      //Si esta seteado solo por $
      maxSoFar = this.cero + this.priceUp;
      reason += ` El maximo es Precio alto $${this.priceUp}`;
    } //Ambos estan definidos o mal definidos. Default es 40% arriba.
    else {
      reason += ` Error en maxSoFar, Se usa valor default 40%. Revisar.\n`;
      maxSoFar = this.cero * 1.4;
    }
    if (this.percentageDown && !this.priceDown) {
      //Si el map existe, y es MAYOR al percentageDown, MAP. Else, PERC.
      if (this.cero * this.percentageDown < this.map) {
        minimumSoFar = this.map;
        reason += ` El minimo es el MAP, contra bajo ${this.percentageDown}%\n`;
      } else {
        minimumSoFar = (this.cero * (this.percentageDown + 100)) / 100;
        reason += ` El minimo es el cero menos ${this.percentageDown}% down. `; //Esto deberia ser NEGATIVO! 
      }
    } else if (!this.percentageDown && this.priceDown) {
      //Si el map existe, y es MAYOR al priceDown, MAP. Else, PriceDown.
      if (this.cero - this.priceDown < this.map) {
        minimumSoFar = this.map;
        reason += ` El minimo es el map contra precio bajo ${this.priceDown}`;
      } else {
        minimumSoFar = this.cero - this.priceDown;
        reason += ` El precio es el cero menos $${this.priceDown}.`;
      }
    }
    return {
      repricerOff: false,
      myOffer: undefined,
      minimo: c(minimumSoFar),
      maximo: c(maxSoFar),
      reason: reason,
      cero: c(this.cero),
      sku: this.sku
    };
  }
  async limitsAndCompetition(){
    let limits = await this.suggestedLimits();
    let competition = await this.getCompetitors();
    if (competition == -1){
        //Error. ignore el item. Ahora, tengo que saltearme todo esto.
        return -1;
    }
    //console.log(competition,limits)
    if (limits.repricerOff){
        return {repricerOff: limits.repricerOff,reason:limits.reason,sku: this.sku,myOffer: competition.myOffer};
    }
    if (typeof competition.myOffer=='undefined'){
      competition.myOffer = '0';
      limits.reason+='No se mi oferta. Creo que estoy inactivo.'
    }
    if (competition.buybox == competition.myOffer){
      return {repricerOff: false, reason: limits.reason+='El buybox es el mismo que mi oferta!.',price:competition.buybox,sku: this.sku,myOffer: competition.myOffer}
    }

    //Si no salio aca, es porque anda. Ahora, veamos si el buybox esta entre limites. 
    if (limits.maximo>=competition.buybox && limits.minimo <= competition.buybox){
        //Esto significa que anda todo bien. Estoy dentro de limites. Puedo copiar buybox.
        return {repricerOff: false,reason:limits.reason+=` y el buybox ${competition.buybox} esta entre limites`,price:competition.buybox,sku:this.sku,myOffer: competition.myOffer}
    }
    else
    {
        if (limits.maximo>=competition.buybox){
            //el problema es el minimo.
            return {repricerOff: false, reason: limits.reason+=` el minimo de es mas alto que el buybox ${competition.buybox}.`,price: limits.minimo,sku:this.sku,myOffer: competition.myOffer}
        }
        else{
            //El problema es el maximo.
            return {repricerOff: false, reason: limits.reason+=` el maximo es mas bajo que el buybox ${competition.buybox} .`, price: limits.maximo,sku:this.sku,myOffer: competition.myOffer}
        }
    }
  }
}

module.exports = RepricerLogic;

//repricer();

let precio = new RepricerLogic('GITA0000877SL');
precio.limitsAndCompetition();
---
| refunds/
| | | refundHandler.js
// AIO refund handler. 

let sellingPartner  = require (`../sellerApiReq`);
const {query} = require('../basicReq');

const now = new Date();
let aWeekAgo = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);
let rightNow = new Date();



async function crearReporteReturns()
{
    try {  
        let res = await sellingPartner.callAPI({
            operation:'createReport',
            endpoint:'reports',
            body:{
        reportType:'GET_FBA_FULFILLMENT_CUSTOMER_RETURNS_DATA',
        dataStartTime: aWeekAgo,
        dataEndTime: rightNow,
        marketplaceIds:['ATVPDKIKX0DER']
        }
    })
    console.log(`El report ID es ${res.reportId}`);
        return res;
        } catch(e){
          console.log(e);
        }
};

async function crearReporteReplacements(){
    try {  
        let res = await sellingPartner.callAPI({
            operation:'createReport',
            endpoint:'reports',
            body:{
        reportType:'GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_REPLACEMENT_DATA',
        dataStartTime: aWeekAgo,
        dataEndTime: rightNow,
        marketplaceIds:['ATVPDKIKX0DER']
        }
    })
    console.log(`El report ID es ${res.reportId}`);
        return res;
        } catch(e){
          console.log(e);
        }
};

async function getReport(id){
    try {
        let report_document = await sellingPartner.callAPI({
      operation:'getReport',
      endpoint:'reports',
      path:{
        reportId: id // retrieve the reportDocumentId from a "getReport" operation (when processingStatus of report is "DONE")
      }
    });
    //log(report_document);
    return (report_document);
      } catch(e){
        console.log(e);
      }
};

async function getReportDocuments(report){
    try {
        let report_document = await sellingPartner.callAPI({
        operation:'getReportDocument',
        endpoint:'reports',
        path:{
        reportDocumentId: report.reportDocumentId // retrieve the reportDocumentId from a "getReport" operation (when processingStatus of report is "DONE")
          }
        });
            //log(report_document);
            return (report_document);
          } catch(e){
            console.log(e);
          }
};
    
async function downloadReport (finalfinal) {
    try {
        let report = await sellingPartner.download(finalfinal, {
        json:true,
    });
        //log(report);
        return report;
    } catch(e){
      console.log(e);
    }
};

async function prepareReport(tipo){
  let finalReport;
  let reportId;
  if (tipo == 'returns')
  reportId = await crearReporteReturns(); //Creating returns.
  else
  if (tipo == 'replacements')
  reportId = await crearReporteReplacements(); //Creating replacements.
  if (typeof reportId == 'undefined'){
    console.log(`Aca no esperamos ni aca eh.`)
    return 0;
  }
  let reportDocument = await getReport(reportId.reportId);
  let status = reportDocument.processingStatus;
  while ((status == 'IN_QUEUE') || (status == 'IN_PROGRESS')){
    console.log(`Patience, my young padawan. ${reportDocument.processingStatus}`)
    reportDocument = await getReport(reportId.reportId);
    status = reportDocument.processingStatus;
    if (status == 'CANCELLED' || status == 'FATAL'){
        console.log('exploto todo.');
      }
  }
  if (status == 'DONE'){
    let downloadUrl = await getReportDocuments(reportDocument);
    finalReport = await downloadReport(downloadUrl);
    return finalReport;
  }
  else
  {
    if (status == 'FATAL' || status == 'CANCELLED'){
      console.log(`Algo salio terriblemente mal. Reporte ${status}`);
      return 0;
    }
  } 
}

class unReturn {
  constructor(return_date,order_id,sku,asin,fnsku,product_name,quantity,fulfillment,disposition,reason,status,license,comments,comprador){
      this.return_date = return_date;
      this.order_id = order_id;
      this.sku = sku;
      this.asin = asin;
      this.fnsku = fnsku;
      this.product_name = product_name.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      this.quantity= quantity;
      this.fulfillment = fulfillment.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      this.disposition = disposition.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      this.reason = reason.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      this.status = status.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      this.license = license.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      this.comments = comments.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
      this.comprador = comprador;
  }
};

async function itemizador(datos,comp){
    let return_date = datos['return-date'];
    let order_id = datos['order-id'];
    let sku = datos['sku'];
    let asin = datos.asin;
    let fnsku = datos['fnsku'];
    let product_name = datos['product-name'];
    let quantity = datos['quantity'];
    let fulfillment = datos['fulfillment-center-id'];
    let disposition = datos['detailed-disposition'];
    let reason = datos['reason'];
    let status = datos['status'];
    let license = datos['license-plate-number'];
    let comments = datos['customer-comments'];
    let comprador = comp;
    let producto = new unReturn (return_date,order_id,sku,asin,fnsku,product_name,quantity,fulfillment,disposition,reason,status,license,comments,comprador);  
    console.log(producto);
    return producto;
};

async function getComprador(item){
  console.log(`Llamando a getComprador con argumento ${item}`)
    let res = await query(`SELECT * FROM datos_pos WHERE sku = '${item}' AND active = 1 LIMIT 1`);
    //console.log(res);
    if (res = []){
      return 0;
    }
    let comprador = res[0].buyer_id;
    console.log(`El comprador es: ${comprador}`);
    return comprador;
};

async function updateReturned(id){
    await query(`UPDATE reporte_prueba SET refunded = 1 WHERE order_id = '${id}'`);
}

async function updateReplaced(reps){
  reps.map(async(replacement)  =>{await query(`UPDATE reporte_prueba SET replaced = 1 WHERE order_id = '${replacement['order-id']}'`)});
}

async function escribirReturns(datos){
  console.log('Arranco a actualizar...')
        for (let i = 0; i < datos.length; i++) {
          let comp = await getComprador(datos[i].sku)
          let producto = await itemizador(datos[i],comp);
          if (producto.buyer_id == 0)
          console.log(`Ignorando ${producto.order_id} por falta de comprador`)
          else
          await createRow(producto);
          await updateReturned(producto.order_id);
        }
};

async function createRow(item){
  console.log(`Agregando refund de ${item.sku}`);
    await query (`INSERT INTO datos_refunds (id_comprador,return_date,order_id,sku,asin,fnsku,product_name,quantity,fulfillment,disposition,reason,status,license,comments,fee_commission,fee_refund_commission,fba_return_unit,costo_unidad,amz_fees,final,procesado) VALUES ('${item.comprador}','${item.return_date}','${item.order_id}','${item.sku}','${item.asin}','${item.fnsku}','${item.product_name}','${item.quantity}', '${item.fulfillment}','${item.disposition}','${item.reason}','${item.status}','${item.license}','${item.comments}','0','0','0','0','0','0','0')`);
    console.log(`Contenido de ${item.sku} agregado.`);
};

async function refundHandler(){
    //This actually does everything. First, returns, then replacements. 
    let returns = await prepareReport('returns');
    let replacements = await prepareReport('replacements');
    if (returns == 0)
    console.log('Returns not working properly');
    else
    await escribirReturns(returns);
    if (replacements == 0)
    console.log('Replacements not working properly');
    //else
    //await updateReplaced(replacements);

}

module.exports = {refundHandler}
---
| | sellerApiReq.js
require('dotenv').config({path: `.env.${process.env.NODE_ENV}`})

const SellingPartnerAPI = require('amazon-sp-api');

let sellingPartner = new SellingPartnerAPI({
    region:'na',
    refresh_token:process.env.AmzToken 
});

module.exports = sellingPartner;
---
| shipments/
| | | shipmentAdvisor.js
//Shipment Advisor. This should let me know which shipments are Working, Shipped, Receiving, missing units, etc. 

const {query} = require('../basicReq');

async function select (){
    console.log( await query(`SELECT * FROM usuarios`));
}

module.exports = {select}

/*




UNDER DEVELOPMENT



*/
---
| sourcing/
| | telegramBot.js
//requests for mysql and SP-API, promises, telegram bot. This

const {query} = require('./basicReq');
var md5 = require('md5');
const Repricer = require('./prices/repricer')
const {procesarListas} = require ('./tools/procesadorDeListasyVentas')

// We need to include payments functionality.
const Payment = require ('./finances/payments/payments');
const {feedbackReport} = require('../src/tools/feedback');


const TelegramBot = require('node-telegram-bot-api');
if (typeof process.env.teleToken !== 'undefined') {
  const bot = new TelegramBot(process.env.teleToken, {polling: true});

class AnmaTelegramBot {constructor (){
  this.loggedUsers = []; //users logueados.
  this.botoneraLoggedIn = [["Ganancias","Stock",'Restock'],["/logout","/nuevoPago","obtener ceros"]]; //Si estas logueado.
  this.botoneraLogin;  [["/login"]]; //Si no estas logueado, logueate
  this.testUser = ''; //Para testear un user pre login. 
  this.testPassword = ''; //Para testear un pw pre login.
  this.testChatId; //ChatID del que testea.
  this.notificationSentToday; //Si ya mande mis mensajes.
  this.liveMessageLog = []; //Log de mensajes. {chatid: '',text: ''}
  this.buscarUsersLogueados(); //Empecemos el bot, incluyendo los que ya estaban.
  this.formHandlerId = 0;
  this.formHandlerCurrentMessage = 0;
  this.tempPago = {id: undefined,type: undefined,amount: undefined,description: undefined,supplierId: undefined,invoiceId: undefined,netTerms: undefined,paymentDate: undefined,dueDate: undefined,poNumber: undefined};
}

async buscarUsersLogueados(){ //Veamos si habia gente logueada.
  try{
    let users = await query(`SELECT * FROM usuarios WHERE telegramChatId IS NOT NULL`);
  users.forEach(user => {
    let newUser =  {user: user.id, chatid: user.telegramChatId,isAdmin: user.es_admin};
    console.log(newUser);
    this.internalLogin(newUser);
  })
  }
  catch(e){
    console.warn (`Error en buscarUsersLogueados, `,e)
  }  
}

async internalLogin(info){ //Login interno. Solo agrega los users que no estan ya creados (evita dups.)
  try{
    if (!this.loggedUsers.includes(info)) // 
    this.loggedUsers.push(info);
  }
  catch(e){
    console.warn (`Error en internalLogin, `,e)
  }
}

async login(){//Login comun.
if (typeof this.testUser == 'undefined' || typeof this.testPassword == 'undefined' || this.testUser == '' || this.testPassword == '') {
  this.testUser = ''; this.testPassword = ''; //Reboot variables justin case.
  return -1; //login failed.
} // if we're here, we're good to go. 
try {
  let users = []; //Traigamos los usuarios con ese nombre.
  users = await query(`SELECT * FROM usuarios WHERE user = '${this.testUser}'`);
  if (users.length == 0) {
    return 0; //no such user.
  }
  if (users.length == 1){
    if (users[0].password == md5(this.testPassword))
    { //login succesfull. Ahora hagamos un objetito.
      let newUser = {user: users[0].id, chatid: this.testChatId,isAdmin: users[0].es_admin}; 
      console.log(newUser);
      //Reiniciemos las variables, ya las usamos.
      this.testUser = this.testPassword = this.testChatId = '';
      if (!this.loggedUsers.includes(newUser)) // Si no esta ya logueado, entonces lo agregamos
      {
        this.loggedUsers.push(newUser);
        bot.sendMessage(newUser.chatid,`Acceso correcto! Bienvenido/a ${users[0].nombre}`);
        bot.activeKeyboard
      }
      else
      {
        //Already logged in? Why? en fin..
        bot.sendMessage(newUser.chatid,`Por favor, quien lo manda a loguearse cuando ya esta logueado? En serio me pone a prueba asi?`);
      }
    }
  }
}
catch(e){
  console.warn (`Error en login, `,e)
}
}

async logout(chatid){
  try{
    this.loggedUsers = this.loggedUsers.filter(user => user.chatid != chatid);
    query (`UPDATE usuarios SET telegramChatId = NULL WHERE telegramChatId = '${chatid}'`);
    console.log(this.loggedUsers);
  } 
  catch(e){
    console.warn (`Error en logout, `,e)
  }
  
}

async logEveryoneOut(){
  try{
    query (`UPDATE usuarios SET telegramChatId = NULL`);
  } 
  catch(e){
    console.warn (`Error en logEveryoneOut, `,e)
  }
}

findUser(chatid){
  //Corroborar si el usuario está logueado.
  return (this.loggedUsers.find(user => user.chatid == chatid))!= undefined;
  }

async formHandler(msg){
  this.liveMessageLog.push(msg);

  /*----------------------------------------------------------------
  Form handler recibe un mensaje, que puede 
  A) Ser un inicializador (como x ej. Nuevo pago.)
  B) Un mensaje post-inizialicación (Como el proveedor al que asignar el pago)
  C) Un mensaje innecesario.

  En caso que sea C, retorna FALSE, y permite el acceso a mensajes comunes. 

  En caso que sea A), enciende una de las sub-funciones de Form, como por ej: Iniciar Pago, o Login, enviando la info necesaria para cada cosa. Al finalizar de recibir y validar la info, retorna una confirmación al usuario y deja de recibir msjs hasta el proximo inicializador. 
  
  INICIALIZADORES! 
  1 == NUEVO PAGO.
  2 == NUEVA PO.
  3 == LOGIN 
  4 == no se. 
----------------------------------------------------------------*/

  if (this.formHandlerId == 0){ 
    //Esto significa que no hay ningun form funcionando. Entonces, preguntamos si es uno de los inicializadores.
    if (msg.text.toString()== "/nuevoPago"){
      this.formHandlerId =1; //INICIA FORM PAGO.
      this.formHandlerCurrentMessage = await this.nuevoPago(msg); //Avisa a pagos que arranque, y se guarda a si mismo.
      return true;
    }
    else
    return false; //Ningun form corriendo, proceda a pie nomas con msjs comunes.
  }
  else {
    //Esto significa que hay algun form corriendo. 
    console.log(`${msg.text.toString()}`)
    if(msg.text.toString() == 'CANCELAR'){ //HAY QUE CANCELAR TODO! 
      if (this.formHandlerId == 1){
        this.nuevoPago('',0);
      }
      bot.sendMessage(msg.chat.id,'Proceso cancelado.');
      this.formHandlerId = 0;
      this.formHandlerCurrentMessage = 0;
      return false;
    }
    else
    { //Hay uno corriendo, y no es para cancelar. Ahora, mandemos al que va.
      if (this.formHandlerId == 1){
        //Pagos. 
        this.formHandlerCurrentMessage = await this.nuevoPago(msg,this.formHandlerCurrentMessage);
        console.log(`Current Message: ${this.formHandlerCurrentMessage}`)
        //console.log(`${this.formHandlerCurrentMessage} es el mensaje actual`);
        if (this.formHandlerCurrentMessage == 666){
          this.formHandlerId = 0;
          //ACA TENGO QUE PONER LA FUNCION DE CREAR PAGO.
          console.table(this.tempPago);
          let res = await this.pagar(this.tempPago);
          if (res != -1){
            bot.sendMessage(msg.chat.id,'Pago añadido correctamente.')
          }
          else {
            bot.sendMessage(msg.chat.id,'Error capturado. Avise a su desarrollador de confianza.')
          }
          this.nuevoPago('',0); //Reinicio pago.
        }
      }
    }
  }
}

async nuevoPago(msg,order){
  if (msg == '' && order == 0)
  {
    this.tempPago == {id: undefined,type: undefined,amount: undefined,description: undefined,supplierId: undefined,invoiceId: undefined,netTerms: undefined,paymentDate: undefined,dueDate: undefined,poNumber: undefined};
    return 0;
  }
  if (msg.text.toString()=='/nuevoPago'){
    //Tengo que pedir el ID, por mensaje. 
    bot.sendMessage(msg.chat.id,'Dando de alta nuevo pago. INGRESE EL ID del pago en caso que sea una actualizacion, o el nro 0 si es un pago nuevo.');
    bot.sendMessage(msg.chat.id,'Si en algun momento desea cancelar la operacion, escriba CANCELAR con mayus.')
    return 1;
  }
  else
  switch (order){
    case 1:{ 
      //1 es id. Recibir ID y pedir Type
      if (parseInt(msg.text.toString()) === 0){
        this.tempPago.id == undefined;
      }
      else {
        this.tempPago.id = parseInt(msg.text.toString());
      }
      bot.sendMessage(msg.chat.id,'Por favor ingrese el tipo de pago.',{
        "reply_markup": {
            "keyboard": [['Pago de PO'],['Gastos']]
            }
          });
          return 2;
    }
    case 2: {
      //type. Recibir type y pedir amount
      if (msg.text.toString() == 'Pago de PO'){
        this.tempPago.type = 'purchaseOrder';
        bot.sendMessage(msg.chat.id,'Ok, necesito el monto (usar solo . para decimales, no usar coma ni separar miles)',{
          "reply_markup": {
              "keyboard": this.botoneraLoggedIn
              }
            })
        return 3;
      }
      else if (msg.text.toString() == 'Gastos'){
        this.tempPago.type = 'expenses';
        bot.sendMessage(msg.chat.id,'Ok, necesito el monto (usar solo . para decimales, no usar coma ni separar miles ni simbolo $)',{
          "reply_markup": {
              "keyboard": this.botoneraLoggedIn
              }
            })
            return 3;
        
      }
      else //Reject and retry.
      bot.sendMessage(msg.chat.id,'Tipo invalido. Por favor use los provistos, no invente. REINTENTE');
      return 2;
    }
    case 3: {
      if (Number.isNaN(parseFloat(msg.text.toString()))){
        bot.sendMessage(msg.chat.id,'Monto invalido. Intente bien esta vez, no me haga programar al pedo. REINTENTE');
        return 3;
      }
      else
      {
        this.tempPago.amount = parseFloat(msg.text.toString());
        bot.sendMessage(msg.chat.id,'Ingrese descripcion del pago. Aca va lo que pinte, o NADA.');
        return 4;
      }
    }
    case 4: {
      this.tempPago.description = msg.text.toString();
      bot.sendMessage(msg.chat.id,'Ingrese supplier Id. Si no lo sabe, pregunte a Max antes de responder. No haga cagadas.');
      return 5;
    }
    case 5: {
      //suplierId y pedir invoiceId
      if (Number.isNaN(parseInt(msg.text.toString()))){
        bot.sendMessage(msg.chat.id,'Para que hablo. PREGUNTAR A MAX SI NO SE SABE. Va un num!! REINTENTE');
        return 5;
      }else{
        this.tempPago.supplierId = parseInt(msg.text.toString());
      bot.sendMessage(msg.chat.id,'Ingrese el numero de Invoice.');
      return 6;
      }
    }
    case 6: {
      //invoiceId y pedir NetTerms
      this.tempPago.invoiceId = msg.text.toString();
      bot.sendMessage(msg.chat.id,'Ingrese net Terms (Cantidad de dias de NET del prov. ES UN NUMERO ENTERO. Si no sabe, pregunte.');
      return 7;
    }
    case 7: {
      //netTerms y pedirPaymentDate
      if (Number.isNaN(parseInt(msg.text.toString()))){
        bot.sendMessage(msg.chat.id,'Ingrese net Terms (Cantidad de dias de NET del prov. ES UN NUMERO ENTERO. No funciono la vez anterior. Por dios.');
        return 7;
      }
      else
      {
        this.tempPago.netTerms = parseInt(msg.text.toString());
        bot.sendMessage(msg.chat.id,'Ingrese dia de pago. (fecha tipo USA (MM-DD-AAAA) o \'HOY\'');
        return 8;
      }
    }
    case 8: {
      //paymentDate y pedir DueDate
      if (msg.text.toString() == 'HOY'){
        this.tempPago.paymentDate = new Date ().toISOString();
      }
      else
      {
        this.tempPago.paymentDate = new Date (msg.text.toString()).toISOString();
      }
      bot.sendMessage(msg.chat.id,'Ingrese Due Date. Cuando habia que pagarlo. Mismo formato que antes, o \'HOY\'')
      return 9;
    }
    case 9: {
      //dueDate y pedir Purchase Order
      if (msg.text.toString() == 'HOY'){
        this.tempPago.dueDate = new Date ().toISOString();
      }
      else
      {
        this.tempPago.dueDate = new Date (msg.text.toString()).toISOString();
      }
      bot.sendMessage(msg.chat.id,'Ingrese numero de PO. NUMERO.')
      return 10;
    }
    case 10: {
      //poNumber y cerrar la request.
      if (Number.isNaN(parseInt(msg.text.toString()))){
        bot.sendMessage(msg.chat.id,'Eso no parece un numero...');
        return 10;
      }
      else {
        this.tempPago.poNumber = parseInt(msg.text.toString());
      }
      bot.sendMessage(msg.chat.id,'Ok, pago inicializado. Iniciando carga...',{
        "reply_markup": {
            "keyboard": this.botoneraLoggedIn
            }
          });
      return 666;
    }
  }
}

async pagar(pago){
  console.log('Pagando...')
  return await Payment.telePayment(pago);
}

async getRestock(chatid){
  if (typeof chatid != 'undefined'){ //Someone asked. 
    //necesito sacar el user, no el chat id.
    let whoAsked = this.loggedUsers.find(user => user.chatid == chatid);
    let notifs = [];
    if (whoAsked == undefined){
      return 0;
    }
    if(whoAsked.isAdmin)
      notifs = await query(`SELECT * from datosRestock`);
    else
      notifs = await query(`SELECT * from datosRestock WHERE comprador = ${whoAsked.user}`);
    console.table(notifs);
    return notifs;
  }
}

async getStock (chatid){
  //Obtener Inventario en Stock.
  //necesito sacar el user, no el chat id.
  try{
    let whoAsked = this.loggedUsers.find(user => user.chatid == chatid);
      if (typeof whoAsked !== 'undefined'){ 
      if (!whoAsked.isAdmin){
        let enStock = await query(`SELECT * FROM botazonStock WHERE id = '${whoAsked.user}'`);
        if (typeof enStock[0] == 'undefined')
        bot.sendMessage(chatid,`No se encontro el stock o no tiene logica.`)
        else
        bot.sendMessage(chatid,`Tiene $${enStock[0].amount} asignado en stock a la venta.`);
      }
      else
      {
        let enStock = await query(`SELECT * FROM botazonStock`);
        enStock.forEach(line => {
          bot.sendMessage(chatid,`USER: ${line.id} Tiene $${line.amount} asignado en stock a la venta.`);  
        })
      }
      } else {
        console.log("No hay un usuario asi.")
      }
      
  }
  catch(err){
    console.log(`Error en getStock`,err)
  }
  
}

async sendNotifications(chatid){
  try {
    let restockOrdenado = [];
    let stockEnExceso = '';
    let stockIdeal = '';
    let stockBajo = '';
    let stockAgotado = '';
if (typeof chatid != 'undefined'){
  //This means it's non-generic. Someone asked.
  let restock = await this.getRestock(chatid);
  if (restock != undefined)
  restock.forEach(line => {
    if (line.daysInStock > 60)
    stockEnExceso+=(`STOCK EN EXCESO: El item ${line.sku} tiene aprox: ${line.daysInStock} dias en stock! \n`);
    else
    if (line.daysInStock > 25)
    stockIdeal+=(`STOCK IDEAL: El item ${line.sku} tiene aprox: ${line.daysInStock} dias en stock! \n`);
    else
    if (line.daysInStock > 10)
    stockBajo+=(`STOCK BAJO: El item ${line.sku} tiene aprox: ${line.daysInStock} dias en stock! \n`);
    else
    if (line.daysInStock == 0)
    stockAgotado+=(`STOCK AGOTADO!: El item ${line.sku} NO TIENE MAS STOCK! \n`);
  })
  if (stockEnExceso !== ''){
    restockOrdenado.push(stockEnExceso);
  }
  if (stockIdeal !== ''){
    restockOrdenado.push(stockIdeal);
  }
  if (stockBajo !== ''){
    restockOrdenado.push(stockBajo);
  }
  if (stockAgotado !== ''){
    restockOrdenado.push(stockAgotado);
  }
  //console.table(restockOrdenado)
  if (restockOrdenado.length > 0){
    for (let i = 0; i < restockOrdenado.length; i++){
      bot.sendMessage(chatid,restockOrdenado[i]);
    }
  }
}
}
catch (e){
  console.log(`Error en sendNotifications: `,e)
  }
//if chat id is defined, send specific notifications, else generic. //NO MORE GENERIC ! Only per request, per user logged.

}

async enviarCeros(chatid){

  if (typeof chatid != 'undefined'){ //Someone asked. 
    //necesito sacar el user, no el chat id.
    let whoAsked = this.loggedUsers.find(user => user.chatid == chatid);
    let ceros = [];
    let proveedores = [];
    if (whoAsked == undefined){
      return 0;
    }
    if(whoAsked.isAdmin){
      ceros = await query(`SELECT * from datos_costos`);
      proveedores = await query (`SELECT * from datos_proveedores`);
      //console.table(proveedores)
    }
    else
    {
      ceros = await query(`SELECT * from datos_costos WHERE buyerId = ${whoAsked.user}`);
      proveedores = await query (`SELECT * from datos_proveedores WHERE id_comprador = ${whoAsked.user}`)
    }
    let notifs = [];
    console.table(ceros)
    ceros.forEach(line =>{
      let provDelItem = proveedores.find(prov => prov.id == line.supplierId);
      console.table(provDelItem)
      if (provDelItem !== undefined)
      notifs.push(`Prov: ${provDelItem.nombre.toUpperCase()}. SKU: ${line.sku}. Ultimo costo: $${parseFloat(line.costo).toFixed(2)}. Cero: ${parseFloat(line.cero).toFixed(2)}.`);
    })
    notifs.sort();
    let bigmsg='';
    notifs.forEach(notif => {
      bigmsg += notif + '\n';
      if (bigmsg.length > 3500){
        bot.sendMessage(chatid, bigmsg);
        bigmsg = '';
      }
  })
    bot.sendMessage(chatid,bigmsg,{
      "reply_markup": {
          "keyboard": this.botoneraLoggedIn
          }
        })
    }
}

async messageHandler(msg){
if (await this.formHandler(msg) == false){ //DEVUELVE FALSO SI NO ES UN MENSAJE IMPORTANTE!

if (msg.text.toString() == '/logout'){
  try{
    this.logout(msg.chat.id);
  bot.sendMessage(msg.chat.id,'Se borraron los registros de Login de su chat, si es que habia. Amargo.',{
    "reply_markup": {
        "keyboard": this.botoneraLogin
        }
      });
  }
  catch(e){
    console.warn (`Error en logout messageHandler, `,e)
  }
}

if (msg.text.toString().startsWith('USER:')){
  let user = msg.text.toString().split(':')[1];
  console.log(msg.chat.id);
  this.testUser = user
  this.testChatId = msg.chat.id;
  bot.sendMessage(msg.chat.id,'Ok, y la contraseña ahora, recorda: PW:ejemplo')
};

if (msg.text.toString().startsWith('PW:')){
  let password = msg.text.toString().split(':')[1];
  this.testChatId = msg.chat.id;
  this.testPassword = password;
  this.login();
};

//Si está logueado, entonces...
if (this.findUser(msg.chat.id)){
if (msg.text.toString().toLowerCase().indexOf('english') === 0){
  bot.sendMessage(msg.chat.id, "OH SORRY THE ARROGANT WANTS THE BOT IN ENGLISH. Well fuck you no tengo ganas de programar dos idiomas, conformate con español jajajaja",{
    "reply_markup": {
        "keyboard": this.botoneraLoggedIn
        }
      });
} else

if (msg.text.toString().toLowerCase().indexOf("español") === 0) {
  bot.sendMessage(msg.chat.id,"Idioma español. Igual no te iba a dejar poner ingles.",{
    "reply_markup": {
        "keyboard": this.botoneraLoggedIn
        }
      });
} else

if (msg.text.toString().toLowerCase().indexOf("procesar listas") === 0){
  bot.sendMessage(msg.chat.id,'Oki doki! Procesando lo que hay...');
  console.log(`oki`)
  procesarListas();
} else
  
if (msg.text.toString().toLowerCase().indexOf("ganancias") === 0) {
  bot.sendMessage(msg.chat.id,"Aca van a ir las ganancias",{
    "reply_markup": {
        "keyboard": this.botoneraLoggedIn
        }
      });
} else

if (msg.text.toString().toLowerCase().indexOf("stock") === 0) {
  this.getStock(msg.chat.id,{
    "reply_markup": {
        "keyboard": this.botoneraLoggedIn
        }
      });
}
else
if (msg.text.toString().toLowerCase().indexOf("restock") === 0) {
  this.sendNotifications(msg.chat.id,{
    "reply_markup": {
        "keyboard": this.botoneraLoggedIn
        }
      });
}
else 
if (msg.text.toString().toLowerCase().indexOf("obtener ceros") === 0){ 
  this.enviarCeros(msg.chat.id);
}
}
else
{
  console.log(msg.chat.id,'No esta autorizado, porque',this.findUser(msg.chat.id));
  bot.sendMessage(msg.chat.id,'No se encuentra autorizado a dicha consulta. Por favor, /login',{
    "reply_markup": {
        "keyboard": this.botoneraLogin
        }
      })  
}
};
}
}

let anmaTeleBot = new AnmaTelegramBot();

//Si necesita ayuda para el login.
bot.onText(/\/login/,(msg) => {
  console.log(msg.text.toString())
  bot.sendMessage(msg.chat.id, "Ingrese Usuario DE ESTA MANERA: USER:ejemplo y en otro mensaje, PW:ejemplo");
})

bot.onText(/\/start/, (msg) => {
  let activeKeyboard = [];
  if (anmaTeleBot.findUser(msg.chat.id)){
    //user already logged in.
    activeKeyboard = anmaTeleBot.botoneraLoggedIn;
  }
  else
  {
    activeKeyboard = anmaTeleBot.botoneraLogin;
    //user needs to log in. 
  }

  bot.sendMessage(msg.chat.id, "Bienvenido al bot de Anma", {
  "reply_markup": {
      "keyboard": activeKeyboard
      }
    });  
});

async function feedbackHandler(){
  let res = await feedbackReport();
  if (res){
      bot.sendMessage(202477440,'Hay un feedback NEGATIVO! Al ataque!');
  }
}
module.exports = {feedbackHandler};
/*
const repricer = new Repricer();
repricer.setup();

setInterval(() => {
    let notifs =  repricer.returnNotifs(true);
    if (notifs?.length > 0){
      console.log(`Holis`)
      notifs.forEach(one =>{
        let msg = `Repricer ${one.repricerOff?'ON':'OFF'}. Item: ${one.active?'Activo':'Inactivo'}, \n Razonamiento: ${one.reason}, Precio: ${one.price}, SKU: ${one.sku}, nuestra oferta ${one.myOffer?one.myOffer:'NO ANDA?'}`
        bot.sendMessage(202477440,msg);
      })
    }
},1000 * 60 * 5)
*/

bot.on("polling_error", (msg) => console.log(msg));

bot.on('message', (msg) => {anmaTeleBot.messageHandler(msg)});
}

//module.exports = bot
---
| | test.js

---
| tools/
| | | calcularVentas.js
const {scrap} = require('./scrapper')

 /*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Esto deberia recibir una categoria "cruda" y devolver ventas. * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 */

 /*
baby_product
beauty
biss
grocery
health_and_beauty
home_improvement
kitchen
office_product
sports

 */

/*
				unknown_binding
				mass_market
				paperback
				hardcover
				school
				library
				cassette
				audioCD
				VHStape
				audio_video
				misc_supplies
				software
				spiral_bound
				cd_rom
				map
				poster
				leather_bound
				accessory
				game_cartridge
				ring_bound
				dvd
				t_shirt
				hat
				microfiche
				board_book
				game
				roughcut
				unbound
				turtleback
				vas
				journal
				flap
				pop-up
				lp_record
				perfect
				mini_disc
				dcc
				consumer_electronics- - - 
				toy- - - 
				gift
				puppet
				game_blocks
				game_computer
				game_video
				game_board
				housewares- - - 
				workbook
				nintendo64
				jewelry- - - 
				stationery
				battery
				miscellaneous
				diskette
				3_5_inch_disk
				3_5_and_5_25_inch_disk
				5_25_inch_disk
				theatrical_release
				license
				volume_license
				multiple_license
				lawn_and_garden- - - 
				digital
				tools
				bundle
				wireless_phone_accessory
				wireless_plan
				wireless_phone_SIMM
				paperback_bunko
				pod_generic
				pod_paperback
				pod_hardback
				wireless_collateral
				tankobon_hardcover
				tankobon_softcover
				magnetic_media
				comic
				mook
				jp_oversized_book
				e-points
				digital_audio_tape
				audio_reel_tape
				baby_product
				film
				slide
				transparency
				microfilm
				card_book
				wall_chart
				audio_download
				rag_book
				dvd_audio
				pc
				prepaid_phone_card
				health_and_beauty - - - 
				target_apparel- - - 
				target_home- - - 
				target_jewelry- - - 
				target_outdoor_sport- - - 
				target_gift
				target_ce
				target_kitchen- - - 
				target_gift_card
				target_luggage
				target_media
				target_beauty- - - 
				target_toys- - - 
				target_hardware
				target_food- - - 
				target_pets- - - 
				target_sports
				cadillac_binding
				bargain_book
				textbook
				laser_disc
				calendar
				pamphlet
				sheet_music
				cards
				consumer_magazine
				plastic_comb
				camera
				game_puzzle
				playstation
				home_improvement
				kitchen
				office_product
				watch
*/

const categories = [
    {
        amazonCategory:'baby_product',
        toolkitCategory:'Baby'
    },
    {
        amazonCategory:'beauty',
        toolkitCategory:'Beauty & Personal Care'
    },
    {
        amazonCategory:'grocery',
        toolkitCategory:'Grocery & Gourmet Food'
    },
    {
        amazonCategory:'health_and_beauty',
        toolkitCategory:'Helath & Household'
    },
    {
        amazonCategory:'home_improvement',
        toolkitCategory:'Tools & Home Improvement'
    },
    {
        amazonCategory:'kitchen',
        toolkitCategory:'Kitchen & Dining'
    },
    {
        amazonCategory:'office_product',
        toolkitCategory:'Office Products'
    },
    {
        amazonCategory:'sports',
        toolkitCategory:'Sports & Outdoors'
    }

]

function translator(category){
    const res = categories.find(one => one.amazonCategory == category);
    return res?res.toolkitCategory:'Not Found';
}

async function estimadorDeVentas(category,rank){
    const traducida = translator(category);
    if (traducida === 'Not Found')
        return -1;
    return await scrap(traducida.toolkitCategory,rank);
}
module.exports = {estimadorDeVentas};
---
| | | feedback.js
/*

Receives every feedback from all 3 marketplaces (USA, CA and MX) that isn't 4 - 5 stars. Saves it into Feedback.


*/

//let {query} = require('./../basicReq');
let sellingPartner  = require (`../sellerApiReq`);

async function createFeedbackReport(){
    try {
        let res = await sellingPartner.callAPI({
          operation:'createReport',
          endpoint:'reports',
          body:{
        reportType:'GET_SELLER_FEEDBACK_DATA',
        marketplaceIds:['ATVPDKIKX0DER','A2EUQ1WTGCTBG2','A1AM78C64UM0Y8'],
        dataStartTime: new Date (new Date().getFullYear(),new Date ().getMonth()-1,1),
        dataEndTime: new Date () 
        }
    })
    console.log(`El report ID es ${res.reportId}`);
        return res;
      } catch(e){
        console.log(e);
      }
}

async function getReport(id){
    try {
        let report_document = await sellingPartner.callAPI({
      operation:'getReport',
      endpoint:'reports',
      path:{
        reportId: id // retrieve the reportDocumentId from a "getReport" operation (when processingStatus of report is "DONE")
      }
    });
    //log(report_document);
    return (report_document);
      } catch(e){
        console.log(e);
      }
};

async function getReportDocuments(report){
    try {
        let reportDocument = await sellingPartner.callAPI({
          operation:'getReportDocument',
          endpoint:'reports',
          path:{
            reportDocumentId: report.reportDocumentId // retrieve the reportDocumentId from a "getReport" operation (when processingStatus of report is "DONE")
          }
    });
    //console.log(report_document);
        return reportDocument;
        } catch(e){
        console.log(e);
    }
};
    
async function downloadReport (report) {
    try {
        let res = await sellingPartner.download(report, {
            json:true,
        });
        return res;
    } catch(e){
    console.log(e);
    }
};

async function feedbackReport(){
    let reportId = await createFeedbackReport();
    reportId = await getReport(reportId.reportId);
    let status = reportId.processingStatus;
    while (status == 'IN_QUEUE' || status == 'IN_PROGRESS'){
        console.log(`Patience, my young padawan. ${reportId.processingStatus}.`);
        reportId = await getReport(reportId.reportId);
        status = reportId.processingStatus;
        if (status == 'CANCELLED' || status == 'FATAL'){
            console.log('Exploto todo');
        }
    }
    if (status == 'DONE'){
        let downloadUrl = await getReportDocuments(reportId);
        reportId = await downloadReport(downloadUrl);
        return true;
    }
    else
    {
      if (status == 'FATAL'){
        console.log(`Algo salio terriblemente mal. Reporte ${status}`);
      } else if (status == 'CANCELLED'){
        console.log(`Esto es una loteria. Puede estar vacio o andar mal... ${status}`);
        return false;
     
      }
    }

}

module.exports = {feedbackReport};
---
| | | procesadorDeListas.js
//Bienvenido a mi nuevo procesador de listas. 

//Plan: Encontrar una lista de UPCs / VENDEDORES, despues copiar todos los items, y procesarlos. 

//HOW TO: 
//Recibo una DB con x cantidad de items. (top 20, 5 veces por seg. y anotar resultados en una response table.)
//Agarro todos los items, y los paso por getMyFeesEstimate, con SL encendido en caso de que price < 9.99 y dims sean menores a N. 
//Luego, anoto todo en la response. SL prendido si es. Intentar guardar marcas!!!!

let sellingPartner  = require (`../sellerApiReq`);
const {query} = require('../basicReq');
//const {scrap} = require('../tools/scrapper')


async function traerItems() {
    let e = await query(`SELECT * FROM datos_listas WHERE processed = 0`);
    if (e?.length > 0 || typeof e?.lenght != 'undefined') 
    return e;
    else
    return 0;
};
 
  //ESTA FUNCION PROCESA UPCs, devuelve ASINES.
  async function upeces (list,nextToken){
    if (nextToken){
        try {
            let res = await sellingPartner.callAPI({
              operation:'searchCatalogItems',
              endpoint:'catalogItems',
              query:{
                pageToken: nextToken,
                pageSize: 20,
                marketplaceIds: 'ATVPDKIKX0DER',
                keywords: list,
                includedData: ['identifiers','summaries'],
            }
                    });
    
                return res;
              } catch(e){
                console.log(e);
              }
    }
    else
    try {
        let res = await sellingPartner.callAPI({
          operation:'searchCatalogItems',
          endpoint:'catalogItems',
          query:{
            Identifiers: list,
            IdentifiersType: 'UPC',
            marketplaceIds: 'ATVPDKIKX0DER',
            keywords: list,
            includedData: ['identifiers','summaries'],
            pageSize: 20, 
        }
                });
            return res;
          } catch(e){
            console.log(e);
          }
  }

async function prices (items,posi){
    let listita = [];
    if (items.length > posi + 20){
        //si la longitud de la lista es MAYOR a la posicion de la lista mas 20, entonces hay mas de 20 para subir. thus, subo los 20, sino, hasta los que haya.
        for (let j = 0; j < 20; j++){
            listita.push(items[posi+j].asin);
        }
    }
        else
        {
            //hay menos de 20 restantes... entonces, proceso los que quedan
            for (let j = 0; j <items.length - posi; j++){
                listita.push(items[posi+j].asin);
            }
        }
    try {
        let res = await sellingPartner.callAPI({
          operation:'getCompetitivePricing',
          endpoint:'productPricing',
          query:{
            Asins: listita,
            ItemType: 'Asin',
            MarketplaceId: 'ATVPDKIKX0DER',}
                });
            return res;
          } catch(e){
            console.log(e);
          }
  }


async function calculadora(item){
    //La calculadora pregunta si es SL.
    //Ok, bueno, determinado eso, rellenamos con info. Si el PV es 0, devuelvo 0 sin probar.
    if ((typeof item.sellingPrice == 'undefined') || (item.sellingPrice == 0)){
        return 0;
    }
    try {
        let res = await sellingPartner.callAPI({
            operation:'getMyFeesEstimateForASIN',
            endpoint:'productFees',
            body:{
                FeesEstimateRequest: {
                    MarketplaceId: 'ATVPDKIKX0DER',
                    IsAmazonFulfilled: true,
                    PriceToEstimateFees:{
                    ListingPrice:{
                        Amount: item.sellingPrice,
                        CurrencyCode: 'USD',
                    },
                    },
                    Identifier: item.asin,
                    OptionalFulfillmentProgram: item.program,
                    }
                },
                    
            path: {
                    Asin: item.asin
                    }
                    }
    );
        let fee = res?.FeesEstimateResult?.FeesEstimate?.TotalFeesEstimate?.Amount;
        return fee;
    }
    catch (err) {
        return 0;
    }
    
}

async function superCalculadora(it){
    const res = await Promise.all(it.map(item => calculadora(item)));
    console.log(res);
    return res;
};

let testUPCResult = [];

class item { constructor (upc, reference, cost,idLista){
    this.upc = upc;
    this.reference = reference;
    this.cost = cost;
    this.idLista = idLista;
}

}
class proceso {
    constructor (Asin){
        this.idLista;
        this.asin = Asin;
        this.upc;
        this.identifier;
        this.netFees; 
        this.sellingPrice; 
        this.cost;
        this.reference;
        this.program; 
        this.title;
        this.brand;
        this.rank; 
        this.category; 
        this.profit; 
    }   
}

function segundoAsignador(itemRes,oldItem){
    let asin = itemRes.asin;
    let resp = new proceso (asin);
    resp.identifier = JSON.stringify(itemRes.identifiers[0].identifiers);
    resp.upc = oldItem.upc;
    resp.title = itemRes.summaries[0].itemName;
    resp.brand = itemRes.summaries[0].brandName;
    resp.cost = oldItem.cost;
    resp.reference = oldItem.reference;
    resp.idLista = oldItem.idLista;
    return resp;
}

function primerAsignador (itemList){
    let res = [];
    for (let i = 0; i < itemList.length; i++) {
        if (!itemList[i].upc == ''){
            let pushi = new item(itemList[i].upc,itemList[i].reference,itemList[i].cost,itemList[i].idLista);
            res.push(pushi);
        }
    }
    return res;
    }

function tercerAsignador(li,pr){
    //Recibo precios y lista, saco nueva lista. 
    for (let i=0; i<li.length; i++){
        for (let j=0; j<pr.length; j++){
            if (li[i].asin == pr[j].ASIN){
                //Asignar a la lista, info de PR. Si tiene precio y si tiene rank. 
                if (typeof pr[j].Product !== 'undefined'){
                    if (typeof pr[j].Product.CompetitivePricing.CompetitivePrices[0] !== 'undefined')
                li[i].sellingPrice = pr[j].Product.CompetitivePricing.CompetitivePrices[0].Price.LandedPrice.Amount;
                if (pr[j].Product.SalesRankings.length){
                    li[i].category = pr[j].Product.SalesRankings[0].ProductCategoryId.slice(0,-19);
                    li[i].rank = pr[j].Product.SalesRankings[0].Rank;
                }
                
                }
                break;
            }
        }
    }
    return li;
}

async function procesarListas (){

    //Agarrar todos los UPCs y eso de un SQL. 
    let test1 = await traerItems();
    let listaNueva = primerAsignador(test1);
    let ciclos = 0; //CONTADOR DE CICLOS. 
    while (ciclos < listaNueva.length / 20)
    {
        let listaUpcs = [];
        for (let i = 0; (i < 20) && (i + 20 * ciclos < listaNueva.length); i++){
            let ii = i + 20 * ciclos;
            listaUpcs.push(listaNueva[ii].upc);
        }
        let res = await upeces(listaUpcs);
        for (let i = 0; i <res.items.length; i++){
            //Aca tengo que ver cual era el que mande... doy vuelta la lista n veces, y no corto aun si encontre...
            for (let j = 0; j<listaNueva.length;j++){
                let stri = JSON.stringify(res.items[i].identifiers[0].identifiers);
                if (stri.includes(listaNueva[j].upc)){
                    testUPCResult.push(segundoAsignador(res.items[i],listaNueva[j]));
                    break;
                }
                else
                {
                    if (j == listaNueva.length -1){
                        console.log('ya vali verga.');
                    }
                }
            }
        }
        if (typeof res.pagination.nextToken !== 'undefined'){
            //Significa que hay mas paginas. 
            //console.log(res);
            let nextToken = res.pagination.nextToken; //Guardo el primer token
            while (typeof nextToken !== 'undefined' ){ //Mientras siga habiendo token nuevo
                let res2 = await upeces(listaUpcs,nextToken); //Envio el token nuevo a pedir lista
                //console.log(res2);
                for (let i = 0; i <res2.items.length; i++) //Aca tengo que ver cual era el que mande... doy vuelta la lista n veces, y corto si encontre...
                for (let j = 0; j <listaNueva.length; j++){
                    let stri = JSON.stringify(res2.items[i].identifiers[0].identifiers);
                    if (stri.includes(listaNueva[j].upc)){
                        testUPCResult.push(segundoAsignador(res2.items[i],listaNueva[j]));
                        break;
                    }
                    else
                    {
                        if (j == listaNueva.length -1){
                            console.log('ya vali verga.');
                        }
                    }
                }
                if (typeof res2.pagination.nextToken !== 'undefined'){
                    nextToken = res2.pagination.nextToken ;
                }
                else{
                    nextToken = undefined;
                    //log('Sublistas procesadas')
                }
             }
        }
        ciclos++;
        console.log(`Obteniendo asines: ${ciclos * 20} de ${listaNueva.length} `)
    }
    //log(testUPCResult);
    //ya tenemos lista de UPC y ASIN con costo, ref, brand, etc. Necesitamos PV.
    let listaPrecios = [];
    for (let i = 0; i < testUPCResult.length; i+=20){
        let precios = await prices(testUPCResult,i);
        for (let j = 0; j<precios.length; j++){
            listaPrecios.push(precios[j]);
        }
        console.log(`Obteniendo precios de venta: ${listaPrecios.length} of ${testUPCResult.length}`);
    }
    //log(listaPrecios);
    testUPCResult = tercerAsignador(testUPCResult,listaPrecios);
    for (u = 0; u < testUPCResult.length; u++){
        //console.log(`${testUPCResult[u].asin} en posicion ${u}`);
    }
    let tercerContador = 0;
    for (let i = 0; i < testUPCResult.length; i=tercerContador){
            let calculo = [];
            let savedPositions = [];
            for (let j = 0; (calculo.length < 10) && (i+j < testUPCResult.length);j++){
                //Si tiene PV, entonces...
                if ((typeof testUPCResult[i+j].sellingPrice != 'undefined') || (testUPCResult[i+j].sellingPrice == 0))
                {
                if (testUPCResult[i+j].sellingPrice <= 10)
                {
                    testUPCResult[i+j].program = 'FBA_SNL';
                    calculo.push(testUPCResult[i+j]);
                    savedPositions.push(i+j);
                    //console.log(`${i+j}: ${testUPCResult[i+j].asin} agregado, SL`);
                    tercerContador++;
                }
                else
                {
                    testUPCResult[i+j].program = 'FBA_CORE';
                    calculo.push(testUPCResult[i+j]);
                    savedPositions.push(i+j);
                    //console.log(`${i+j}: ${testUPCResult[i+j].asin} agregado, CORE`);
                    tercerContador++;
                }
            }
            else{
                console.log(`${testUPCResult[i+j].asin} no tiene PV. Voy ${i+j}`);
                tercerContador++;
            }
            
            }
            const fees = await superCalculadora(calculo);
            for (let i=0; i<fees.length; i++){
                if (!fees[i] == 0)
                {
                    testUPCResult[savedPositions[i]].netFees = fees[i];
                    testUPCResult[savedPositions[i]].profit = testUPCResult[savedPositions[i]].sellingPrice - testUPCResult[savedPositions[i]].cost - testUPCResult[savedPositions[i]].netFees; 
                }  
            }
        }
    //LIMPIO LA LISTA con .replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
    for (let i = 0; i < testUPCResult.length; i++){
        let a = testUPCResult[i];
        if (typeof a.identifier != 'undefined')
        testUPCResult[i].identifier = a.identifier.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        if (typeof a.reference != 'undefined')
        testUPCResult[i].reference = a.reference.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        if (typeof a.title != 'undefined')
        testUPCResult[i].title = a.title.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        if (typeof a.brand != 'undefined')
        testUPCResult[i].brand = a.brand.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
    }

    //Tengo que escribir todo ahora. 
    for (let i = 0; i < testUPCResult.length; i++){
        let a = testUPCResult[i];
        //console.log(a);
        await query (`INSERT INTO datos_listas_procesadas (idLista,reference,upc,cost,identifier,netFees,sellingPrice,program,title,brand,rank,category,profit,asin,processed) VALUES ('${a.idLista}','${a.reference}','${a.upc}','${a.cost}','${a.identifier}','${a.netFees}','${a.sellingPrice}','${a.program}','${a.title}','${a.brand}','${a.rank}','${a.category}','${a.profit}','${a.asin}','${a.processed}')`);
    }
    await query (`UPDATE datos_listas SET processed = '1' WHERE processed = '0' `);
    console.log(`all set.`);
}

module.exports = {procesarListas};

---
| | | procesadorDeListasyVentas.js
//Bienvenido a mi nuevo procesador de listas. 

//Plan: Encontrar una lista de UPCs / VENDEDORES, despues copiar todos los items, y procesarlos. 

//HOW TO: 
//Recibo una DB con x cantidad de items. (top 20, 5 veces por seg. y anotar resultados en una response table.)
//Agarro todos los items, y los paso por getMyFeesEstimate, con SL encendido en caso de que price < 9.99 y dims sean menores a N. 
//Luego, anoto todo en la response. SL prendido si es. Intentar guardar marcas!!!!

let sellingPartner  = require (`../sellerApiReq`);
const {query} = require('../basicReq');
let {estimadorDeVentas} = require('./calcularVentas')


async function traerItems() {
    let e = await query(`SELECT * FROM datos_listas WHERE processed = 0`);
    if (e?.length > 0 || typeof e?.lenght != 'undefined') 
    return e;
    else
    return 0;
};
 
  //ESTA FUNCION PROCESA UPCs, devuelve ASINES.
  async function upeces (list,nextToken=undefined){
        try {
            let res = await sellingPartner.callAPI({
              operation:'searchCatalogItems',
              endpoint:'catalogItems',
              query:{
                pageToken: nextToken,
                pageSize: 20,
                marketplaceIds: 'ATVPDKIKX0DER',
                keywords: list,
                includedData: ['identifiers','summaries'],
            }
                    });
    
                return res;
              } catch(e){
                console.log(e);
              }
    }

async function prices (items,posi){
    let listita = [];
    if (items.length > posi + 20){
        //si la longitud de la lista es MAYOR a la posicion de la lista mas 20, entonces hay mas de 20 para subir. thus, subo los 20, sino, hasta los que haya.
        for (let j = 0; j < 20; j++){
            listita.push(items[posi+j].asin);
        }
    }
        else
        {
            //hay menos de 20 restantes... entonces, proceso los que quedan
            for (let j = 0; j <items.length - posi; j++){
                listita.push(items[posi+j].asin);
            }
        }
    try {
        let res = await sellingPartner.callAPI({
          operation:'getCompetitivePricing',
          endpoint:'productPricing',
          query:{
            Asins: listita,
            ItemType: 'Asin',
            MarketplaceId: 'ATVPDKIKX0DER',}
                });
            return res;
          } catch(e){
            console.log(e);
          }
  }


async function calculadora(item){
    //La calculadora pregunta si es SL.
    //Ok, bueno, determinado eso, rellenamos con info. Si el PV es 0, devuelvo 0 sin probar.
    if ((typeof item.sellingPrice == 'undefined') || (item.sellingPrice == 0)){
        return 0;
    }
    try {
        let res = await sellingPartner.callAPI({
            operation:'getMyFeesEstimateForASIN',
            endpoint:'productFees',
            body:{
                FeesEstimateRequest: {
                    MarketplaceId: 'ATVPDKIKX0DER',
                    IsAmazonFulfilled: true,
                    PriceToEstimateFees:{
                    ListingPrice:{
                        Amount: item.sellingPrice,
                        CurrencyCode: 'USD',
                    },
                    },
                    Identifier: item.asin,
                    OptionalFulfillmentProgram: item.program,
                    }
                },
                    
            path: {
                    Asin: item.asin
                    }
                    }
    );
        let fee = res?.FeesEstimateResult?.FeesEstimate?.TotalFeesEstimate?.Amount;
        return fee;
    }
    catch (err) {
        return 0;
    }
    
}

async function superCalculadora(it){
    const res = await Promise.all(it.map(item => calculadora(item)));
    console.log(res);
    return res;
};

let testUPCResult = [];

class item { constructor (upc, reference, cost,idLista){
    this.upc = upc;
    this.reference = reference;
    this.cost = cost;
    this.idLista = idLista;
}

}
class proceso {
    constructor (Asin){
        this.idLista;
        this.asin = Asin;
        this.upc;
        this.identifier;
        this.netFees; 
        this.sellingPrice; 
        this.cost;
        this.reference;
        this.program; 
        this.title;
        this.brand;
        this.rank; 
        this.category; 
        this.profit; 
    }   
}

function segundoAsignador(itemRes,oldItem){
    let asin = itemRes.asin;
    let resp = new proceso (asin);
    resp.identifier = JSON.stringify(itemRes.identifiers[0].identifiers);
    resp.upc = oldItem.upc;
    resp.title = itemRes.summaries[0].itemName;
    resp.brand = itemRes.summaries[0].brandName;
    resp.cost = oldItem.cost;
    resp.reference = oldItem.reference;
    resp.idLista = oldItem.idLista;
    return resp;
}

function primerAsignador (itemList){
    let res = [];
    for (let i = 0; i < itemList.length; i++) {
        if (!itemList[i].upc == ''){
            let pushi = new item(itemList[i].upc,itemList[i].reference,itemList[i].cost,itemList[i].idLista);
            res.push(pushi);
        }
    }
    return res;
    }

function tercerAsignador(li,pr){
    //Recibo precios y lista, saco nueva lista. 
    for (let i=0; i<li.length; i++){
        for (let j=0; j<pr.length; j++){
            if (li[i].asin == pr[j].ASIN){
                //Asignar a la lista, info de PR. Si tiene precio y si tiene rank. 
                if (typeof pr[j].Product !== 'undefined'){
                    if (typeof pr[j].Product.CompetitivePricing.CompetitivePrices[0] !== 'undefined')
                li[i].sellingPrice = pr[j].Product.CompetitivePricing.CompetitivePrices[0].Price.LandedPrice.Amount;
                if (pr[j].Product.SalesRankings.length){
                    li[i].category = pr[j].Product.SalesRankings[0].ProductCategoryId.slice(0,-19);
                    li[i].rank = pr[j].Product.SalesRankings[0].Rank;
                    estimadorDeVentas(li[i].category,li[i].rank).then((value) =>{
                        li[i].sales = value;
                    }
                    )}
                
                }
                break;
            }
        }
    }
    return li;
}

async function procesarListas (){

    //Agarrar todos los UPCs y eso de un SQL. 
    console.log('Procesando LISTASSSSS')
    let test1 = await traerItems();
    let listaNueva = primerAsignador(test1);
    let ciclos = 0; //CONTADOR DE CICLOS. 
    while (ciclos < listaNueva.length / 20)
    {
        let listaUpcs = [];
        for (let i = 0; (i < 20) && (i + 20 * ciclos < listaNueva.length); i++){
            let ii = i + 20 * ciclos;
            listaUpcs.push(listaNueva[ii].upc);
        }
        let res = await upeces(listaUpcs);
        for (let i = 0; i <res.items.length; i++){
            //Aca tengo que ver cual era el que mande... doy vuelta la lista n veces, y no corto aun si encontre...
            for (let j = 0; j<listaNueva.length;j++){
                let stri = JSON.stringify(res.items[i].identifiers[0].identifiers);
                if (stri.includes(listaNueva[j].upc)){
                    testUPCResult.push(segundoAsignador(res.items[i],listaNueva[j]));
                    break;
                }
                else
                {
                    if (j == listaNueva.length -1){
                        console.log('ya vali verga.');
                    }
                }
            }
        }
        if (typeof res.pagination.nextToken !== 'undefined'){
            //Significa que hay mas paginas. 
            //console.log(res);
            let nextToken = res.pagination.nextToken; //Guardo el primer token
            while (typeof nextToken !== 'undefined' ){ //Mientras siga habiendo token nuevo
                let res2 = await upeces(listaUpcs,nextToken); //Envio el token nuevo a pedir lista
                //console.log(res2);
                for (let i = 0; i <res2.items.length; i++) //Aca tengo que ver cual era el que mande... doy vuelta la lista n veces, y corto si encontre...
                for (let j = 0; j <listaNueva.length; j++){
                    let stri = JSON.stringify(res2.items[i].identifiers[0].identifiers);
                    if (stri.includes(listaNueva[j].upc)){
                        testUPCResult.push(segundoAsignador(res2.items[i],listaNueva[j]));
                        break;
                    }
                    else
                    {
                        if (j == listaNueva.length -1){
                            console.log('ya vali verga.');
                        }
                    }
                }
                if (typeof res2.pagination.nextToken !== 'undefined'){
                    nextToken = res2.pagination.nextToken ;
                }
                else{
                    nextToken = undefined;
                    //log('Sublistas procesadas')
                }
             }
        }
        ciclos++;
        console.log(`Obteniendo asines: ${ciclos * 20} de ${listaNueva.length} `)
    }
    //log(testUPCResult);
    //ya tenemos lista de UPC y ASIN con costo, ref, brand, etc. Necesitamos PV.
    let listaPrecios = [];
    for (let i = 0; i < testUPCResult.length; i+=20){
        let precios = await prices(testUPCResult,i);
        for (let j = 0; j<precios.length; j++){
            listaPrecios.push(precios[j]);
        }
        console.log(`Obteniendo precios de venta: ${listaPrecios.length} of ${testUPCResult.length}`);
    }
    //log(listaPrecios);
    testUPCResult = tercerAsignador(testUPCResult,listaPrecios);
    for (u = 0; u < testUPCResult.length; u++){
        //console.log(`${testUPCResult[u].asin} en posicion ${u}`);
    }
    let tercerContador = 0;
    for (let i = 0; i < testUPCResult.length; i=tercerContador){
            let calculo = [];
            let savedPositions = [];
            for (let j = 0; (calculo.length < 10) && (i+j < testUPCResult.length);j++){
                //Si tiene PV, entonces...
                if ((typeof testUPCResult[i+j].sellingPrice != 'undefined') || (testUPCResult[i+j].sellingPrice == 0))
                {
                if (testUPCResult[i+j].sellingPrice <= 10)
                {
                    testUPCResult[i+j].program = 'FBA_SNL';
                    calculo.push(testUPCResult[i+j]);
                    savedPositions.push(i+j);
                    //console.log(`${i+j}: ${testUPCResult[i+j].asin} agregado, SL`);
                    tercerContador++;
                }
                else
                {
                    testUPCResult[i+j].program = 'FBA_CORE';
                    calculo.push(testUPCResult[i+j]);
                    savedPositions.push(i+j);
                    //console.log(`${i+j}: ${testUPCResult[i+j].asin} agregado, CORE`);
                    tercerContador++;
                }
            }
            else{
                console.log(`${testUPCResult[i+j].asin} no tiene PV. Voy ${i+j}`);
                tercerContador++;
            }
            
            }
            const fees = await superCalculadora(calculo);
            for (let i=0; i<fees.length; i++){
                if (!fees[i] == 0)
                {
                    testUPCResult[savedPositions[i]].netFees = fees[i];
                    testUPCResult[savedPositions[i]].profit = testUPCResult[savedPositions[i]].sellingPrice - testUPCResult[savedPositions[i]].cost - testUPCResult[savedPositions[i]].netFees; 
                }  
            }
        }
    //LIMPIO LA LISTA con .replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
    for (let i = 0; i < testUPCResult.length; i++){
        let a = testUPCResult[i];
        if (typeof a.identifier != 'undefined')
        testUPCResult[i].identifier = a.identifier.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        if (typeof a.reference != 'undefined')
        testUPCResult[i].reference = a.reference.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        if (typeof a.title != 'undefined')
        testUPCResult[i].title = a.title.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
        if (typeof a.brand != 'undefined')
        testUPCResult[i].brand = a.brand.replace(/[&\/\\#,+()$~%.'":*?<>{}]/g, "");
    }

    //Tengo que escribir todo ahora. 
    for (let i = 0; i < testUPCResult.length; i++){
        let a = testUPCResult[i];
        //console.log(a);
        await query (`INSERT INTO datos_listas_procesadas (idLista,reference,upc,cost,identifier,netFees,sellingPrice,program,title,brand,rank,category,profit,asin,sales,processed) VALUES ('${a.idLista}','${a.reference}','${a.upc}','${a.cost}','${a.identifier}','${a.netFees}','${a.sellingPrice}','${a.program}','${a.title}','${a.brand}','${a.rank}','${a.category}','${a.profit}','${a.asin}','${a.sales}','${a.processed}')`);
    }
    await query (`UPDATE datos_listas SET processed = '1' WHERE processed = '0' `);
    console.log(`all set.`);
};

module.exports = {procesarListas};
---
| | | scrapper.js
const puppeteer = require('puppeteer');
require('events').EventEmitter.defaultMaxListeners = 50;

async function autoScroll(page) {
    await page.evaluate(async () => {
        await new Promise((resolve, reject) => {
            var totalHeight = 0;
            var distance = 100;
            var timer = setInterval(() => {
                var scrollHeight = document.body.scrollHeight;
                window.scrollBy(0, distance);
                totalHeight += distance;

                if (totalHeight >= scrollHeight) {
                    clearInterval(timer);
                    resolve();
                }
            }, 100);
        });
    });
}
const sleep = (s) => new Promise((resolve) => setTimeout(resolve, 1000 * s));

async function scrap(category , number) {
    const browser = await puppeteer.launch({
        headless: true,
        defaultViewport: false,
        userDataDirl: "./tmp"
    });
    const obj = {
        cat: "",
        days: 0,
        i: 0,
    }
    obj.cat = category;
    obj.days = number;
    const page = await browser.newPage();
    if (page === undefined)
    {
        console.error("failed in create a new tab");
        return(375732)
    }
    await page.goto("https://fbatoolkit.com/");
    if (page.goto == null)
    {
        console.error("failed in opening website");
        return (404);

    }
    await autoScroll(page);
    const delaySelector = await page.waitForSelector(".chart-container:last-of-type");
    if (delaySelector == null)
    {
        console.error("failed to load selector");
        return (-1);
    }
    var index = await page.evaluate((obj) => {
        var data = document.querySelectorAll('.chart-container');
        console.log('Revisando')
        if (!data)
            return null;
        var category;
        for (let i = 1; i < data.length; i++) {
            var cmp = data[i].innerText.split("\n")[1];
            cmp = cmp.toLowerCase();
            cmp =  cmp.replace(/\s+/g, '')
            var inp = obj.cat;
            inp = inp.toLowerCase();
            inp =  inp.replace(/\s+/g, '')
            if (cmp === inp)
            {
                category = data[i].querySelector(".chart").innerText.split("\n").shift(0);
                var input = data[i].querySelector("input").value = obj.days;
                const SubmitBtn = data[i].querySelector(".estimator-submit").click();
                return({
                    category : category,
                    index : i - 1,
                })
            }
        }
       return (404);
    }, obj)
    if (!index)
    {
        console.error("error in evaluator method");
        return;
    }
    if(index == 404){
        await browser.close();
        console.error("try to input correct arguments");
        return;
    }
    await sleep(3);
    var data = await page.$$('.chart-container > .estimator-container');
    if (!data)
    {
        await browser.close();
        console.error("there's no container in this webpage");
        return ;
    }
    let result = await page.evaluate(el => el.innerText.split("\n")[1].split(' (')[0].split(' ').pop(-1), data[index.index])
    if (!result)
    {
        await browser.close();
        return null;

    }
    //console.log("this is the result " + result);
    await browser.close();
    return result;
};

module.exports = {scrap}
/*
scrap("Office Products", 13000).then(value => {
    console.log(value)
});*/
---
| | | smallAndLight.js
//smallAndLight.js

let sellingPartner  = require (`../sellerApiReq`);
const {query} = require ('../../src/basicReq');


async function selectAllItems(){
    let res = await query(`SELECT * FROM datos_items`);
    let retorno = [];
    for (let i = 0; i < res.length; i++) {
        retorno.push(res[i].sku);
    }
    return retorno;
}

async function areElegible(u){
    if (u.length > 0 || typeof u != 'undefined') {
        let retorno = [];
        for (let i = 0; i < u.length; i++) {
            let res = await llamarElegible(u[i])
            if (res)
            {
                retorno.push(u[i]);
            }
        }
        console.log(retorno)
        return retorno;
    }
    else
    return 0;
}

async function areEnrolled(u){
    let retorno = [];
    for (let i = 0;i<u.length; i++) {
        let j = await getEnrollment(u[i]);
        if (j === false){
            console.log(`${u[i]} deberia ser Small and Light!`);
        }
        
    }
}

async function getEnrollment(u){
    try {
      let res = await sellingPartner.callAPI({
        operation:'getSmallAndLightEnrollmentBySellerSKU',
        endpoint:'fbaSmallAndLight',
        path: {sellerSKU: u},
        query:{marketplaceIds: 'ATVPDKIKX0DER'}
                });
          if (res.status == 'ENROLLED')
          return true;
          else
          return false;   
        } catch(e){
        console.log(e);
        }
    }

async function llamarElegible(u){
    try {
        let res = await sellingPartner.callAPI({
          operation:'getSmallAndLightEligibilityBySellerSKU',
          endpoint:'fbaSmallAndLight',
          path: {sellerSKU: u},
          query:{marketplaceIds: 'ATVPDKIKX0DER'}
                  });

            if (res.status == 'ELIGIBLE')
            {
                return true;
            }  
            else{
                console.log(`${u} NO!`)
                return false;
            }
               
          } catch(e){
            console.log(`SKU: ${u}, ${e}`);
            return false;
          }
      }

async function smallAndLightTool(){
    let selected = await selectAllItems();
    //log(selected);
    let elegibility = await areElegible(selected);
    if (elegibility == 0){
        return 0;
    }
    else{
        await areEnrolled(elegibility);
    }
    
}
module.exports = {smallAndLightTool};
---
views/
